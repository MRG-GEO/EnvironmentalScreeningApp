<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Export Esri Map to PDF</title>

  <!-- Load jsPDF first -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.22/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/pdf-lib"></script>
  <script src="https://unpkg.com/jspdf"></script>
  <script src="https://cdn.jsdelivr.net/npm/to-geojson@0.5.0/dist/to-geojson.min.js"></script>
  <script type="module" src="https://js.arcgis.com/calcite-components/2.6.0/calcite.esm.js"></script>
  <link rel="stylesheet" href="https://js.arcgis.com/calcite-components/2.6.0/calcite.css" />
  <link rel="stylesheet" href="https://js.arcgis.com/4.31/esri/themes/light/main.css" />
  <style>
     html,
    body {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: "Avenir Next";
    }
    calcite-shell{
        width: 100%;
        height: 100%;
        overflow-y: hidden;
        background-color: aqua;
    }

    #screening-Tools{
        width: 600px;
    }

    #bufferControls {
        margin-bottom: 10px;
        padding: 10px;
        background: #f4f4f4;
        border-radius: 5px;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 10px;
    }

    #bufferDistance {
        width: 80px;
        height: 15px;
        padding: 5px;
        font-family: "Avenir Next"; 
    }

    #bufferUnits{
        height: 30px;
        font-family: "Avenir Next";
    }

    #bufferButtons{
        margin-left: 10px;
        display: flex;
        flex-direction: column;
        row-gap: 8px;
    }

    .BufferButtons{
        background: #0079c1;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 3px;
        font-family: "Avenir Next";
    }

    .BufferButtons:hover{
        background: #005a8d;
    }

    #importExport{
        display: flex;
        flex-direction: row;
    }

    #uploadButton{
        color: aliceblue;
        margin-top: 10px;
        width: 35%;
        align-self: center;
        border: solid 1px grey;
        background-color:#007ac2;
        padding: 3px;
    }

    #uploadButton:hover{
        color: aliceblue;
        margin-top: 10px;
        width: 35%;
        align-self: center;
        cursor: pointer;
        border: solid 1px grey;
        background-color:#004874;
        padding: 3px;
    }

    #createLayers{
        position: relative;
    }

    #createLayerButton{
        position: absolute;
        right: 20px;
        color: aliceblue;
        margin-top: 10px;
        width: 100px;
        border: solid 1px grey;
        background-color:#007ac2;
        padding: 3px;
    }
    #createLayerButton:hover{
        color: aliceblue;
        margin-top: 10px;
        width: 100px;
        cursor: pointer;
        border: solid 1px grey;
        background-color:#004874;
        padding: 3px;
    }

    #uploadedLayersList{
        padding-top:30px;
        height: auto;
    }

    #right-panel{
        width: 100%;
        overflow: hidden;
        background-color: pink;
    }
 
    #sketchContainer{
        position: relative;
        padding-bottom: 5px;
    }
    #toolTips{
        width: 400px;
        height: 800px;
        overflow-y: scroll;
    }
    
    #Layers{ 
        width: 100%;
        height: 800px; 
        overflow: auto;
    }

    .LayerBlock{
        margin: 0;
    }
    
    #mapContainer {
        position: relative;
        height: 400px; /* Default height */
        overflow: clip;
    }

    
    #mapDiv {
        position: relative;
        height: 90%;
        background: lightgray; /* Placeholder background */
    }
    #exportFrameOverlay {
        position: absolute;
        border: 2px dashed red;
        top: 150px;     /* Example: vertical positioning */
        left: 100px;    /* Example: horizontal positioning */
        pointer-events: none;
        z-index: 10;
        display: none;
    }
    #resizeHandle {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%); /* Center horizontally */
        display: flex;
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items */
        justify-content: center;
        width: 100%; /* Adjust as needed */
        height: 20px; /* Adjust as needed */
        background: #616161; /* Esri blue */
        cursor: ns-resize;
        border-radius: 5px;
        overflow: hidden;
    }
    #resizeHandle calcite-icon {
        color: white;
        width: 16px;
        height: 16px;
    }

    .importLi {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5em;
        position: relative;
        width: 80%;
    }
    .liLeft {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .liRight{
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 3px; 
    }

    #clearBtn{
        border: solid 1px grey;
        background-color: white;
        padding: 3px;
        margin: 3px;
        align-self: center;
    }
    #clearBtn:hover{
        border: solid 1px grey;
        background-color:rgb(212, 212, 212);
        padding: 3px;
        margin: 3px;
        cursor: pointer;
    }
   
    
    #exportSplit{
        align-self: center;
    }
    
    #exportDiv{
        width: 100%;
    }

    #export{
        width: 100%;
        display: flex;
        flex-direction: row;
        overflow: hidden;
        gap: 10px;
        height: 100%;
    }

    #showExportFrame{
        border: solid 1px grey;
        background-color: white;
        align-content: center;
        align-self: center;
        padding: 3px;
        height: 25px;
    }
    #showExportFrame:hover{
        border: solid 1px grey;
        background-color:rgb(212, 212, 212);
        cursor: pointer;
    }

    #pdfLoader{
        position: relative;
        align-self: center;
        width: 30px;
        height: 30px;
        background: none;
        display: none;
    }

    #exportButton{
        border: solid 1px grey;
        background-color:white;
        padding: 3px;
        margin: 3px;
    }
    #exportButton:hover{
        border: solid 1px grey;
        background-color:rgb(212, 212, 212);
        cursor: pointer;
    }

    #csvButton{
        border: solid 1px grey;
        background-color:white;
        padding: 3px;
        margin: 3px;
    }

    #centreButtonDiv{
        border: solid 1px grey;
        background-color: white;
        padding: 3px;
        margin: 3px;
    }
    #centreButtonDiv:hover{
        border: solid 1px grey;
        background-color:rgb(212, 212, 212);
        padding: 3px;
        margin: 3px;
        cursor: pointer;
    }
    #results {
        justify-self: center;
        width: 98%;
        background-color: white;
        margin-top: 10px;
        margin-left: 10px;
        border: 1px solid #ccc;
        max-height: 500px;
        overflow-y: scroll;
        
    }
    #refreshButton{
        border: solid 1px grey;
        background-color: white;
        padding: 3px;
        margin: 3px;
        width: 80px;
    }
    #refreshButton:hover{
        border: solid 1px grey;
        background-color:rgb(212, 212, 212);
        padding: 3px;
        margin: 3px;
        cursor: pointer;
    }
    #refresh{
        margin-left: 10px;
    }

    #tableContainer{
        width: 100%;
        min-height: 200px;
        overflow: scroll;
    }
    
    calcite-block[open] > div[slot="summary"] {
        display: flex;
        align-items: left;
        justify-content: space-between;
    }

    calcite-action calcite-switch  {
        margin-left: auto;
        margin-right: 0px;
        pointer-events: auto;
    }
    #popover-trigger {
        margin-inline: 1rem;
    }
    .SelectionTool{
        display: flex;
        flex-direction: row;
    }
    #container{
        margin: 0;
    }
    .tabs {
      display: flex;
      flex-direction: column;
      font-family: sans-serif;
    }
  
    .tab-headers {
        display: flex;
        border-bottom: 1px solid #ccc;
    }

    .tab-header {
        padding: 10px 16px;
        cursor: pointer;
        user-select: none;
        border: 1px solid transparent;
        border-bottom: none;
        background: #f0f0f0;
        margin-right: 4px;
        border-radius: 4px 4px 0 0;
    }

    .tab-header.active {
        background: white;
        border: 1px solid #ccc;
        border-bottom: 1px solid white;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    #featureListButton {
        cursor: pointer;
        padding: 10px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        margin-right: 5px;
    }

    #featureListButton.active {
        background-color: #ccc;
    }

    /* Style for static content */
    #featureListTab {
        padding: 20px;
        background-color: #fff;
        border: 1px solid #ccc;
    }
    
    </style>

</head>
<body>
    <calcite-shell slot="panel-start" position="start">
        <calcite-shell-panel id="left-panel" heading="Map Options" slot="panel-start" position="start" style="--calcite-shell-panel-min-width: 500px">
                <calcite-button icon-start="information" text-enabled id="popover-trigger">Tool Tips</calcite-button>
                <calcite-popover id="toolTips" heading="Tool tips" reference-element="popover-trigger"placement="bottom" pointer-disabled overlay-positioning="fixed" auto-close>
                    <div id="toolTips">
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="cursor"/>
                            </div>
                            <div>
                                <h3>Selection tool</h3>
                                <p>Select individual features to see attribute information.</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="cursor-marquee" />
                            </div>
                            <div>
                                <h3>Rectangle Selection tool</h3>
                                <p>Only works to select elemets drawn on the map using the sketch tool (I donno man, at this point I give up trying to fix it).</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="lasso-select" />
                            </div>
                            <div>
                                <h3>Lasso Selection tool</h3>
                                <p>Only works to select elemets drawn on the map using the sketch tool (again, I give up).</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="pin" />
                            </div>
                            <div>
                                <h3>Draw a point</h3>
                                <p>Absolutely useless, but I can't get rid of it.</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="line" />
                            </div>
                            <div>
                                <h3>Draw a line</h3>
                                <p>If you find a use for this let me know.</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="polygon" />
                            </div>
                            <div>
                                <h3>Draw a polygon</h3>
                                <p>Use this to select layers to export.</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="rectangle" />
                            </div>
                            <div>
                                <h3>Draw a rectangle</h3>
                                <p>Use this to select layers to export.</p>
                            </div>
                        </div>
                        <div class="SelectionTool">
                            <div>
                                <calcite-icon icon="circle" />
                            </div>
                            <div>
                                <h3>Draw a circle</h3>
                                <p>But why?</p>
                            </div>
                        </div>
                    </div>
                </calcite-popover>
                <div id="sketchContainer"></div>
                <div id="clearBtn"><calcite-icon icon="clear-selection" scale="s"/></calcite-icon> Clear Selection</div>
                <calcite-block collapsible close heading="Geoprocessing Tools" icon-start="wrench">
                    <div id="bufferControls">
                        <label for="bufferDistance">Buffer Distance:</label>
                        <input type="number" id="bufferDistance" value="100" min="1">
                        <label for="bufferUnits">Units:</label>
                        <select id="bufferUnits">
                            <option value="meters">Meters</option>
                            <option value="kilometers">Kilometers</option>
                        </select>
                        <div id="bufferButtons">
                            <button class="BufferButtons" id="applyBuffer">Apply Buffer</button>
                        </div>
                    </div>
                </calcite-block>
                <calcite-block collapsible close heading="Import / Export / Create Layers from Selected Features" icon-start="layers-f" id="createLayers">
                    <div id="importExport">
                        <input type="file" id="fileInput" accept=".kml,.kmz,.gpx" style="display:none"/>
                        <div id="uploadButton"><calcite-icon icon="upload" scale="s"/></calcite-icon> Import KML/KMZ/GPX</div>
                        <div id="createLayerButton"><calcite-icon icon="duplicate" scale="s"/></calcite-icon> New Layer</div>
                    </div>
                    <ul id="uploadedLayersList"></ul>
                </calcite-block>
                <calcite-block collapsible close heading="Export Map" icon-start="export" id="exportDiv">
                    <div id="export">
                        <div id="showExportFrame">Map Frame Extent</div>
                        <calcite-split-button id="exportSplit"primary-text="Export" primary-icon-start="export">
                                <calcite-dropdown-item id="exportPDFButton"><calcite-icon icon="file-pdf" scale="s" style="margin-right: 5px;"></calcite-icon>Export to PDF</calcite-dropdown-item>
                                <calcite-dropdown-item id="exportGeoPDF"><calcite-icon icon="file-pdf" scale="s" style="margin-right: 5px;"></calcite-icon>Export GeoPDF</calcite-dropdown-item>
                                <calcite-dropdown-item id="csvButton"><calcite-icon icon="file-csv" scale="s" style="margin-right: 5px;"></calcite-icon>Export to CSV</calcite-dropdown-item>
                        </calcite-split-button>
                        <div id="pdfLoader" class="esri-component esri-widget">
                            <calcite-loader active type="indeterminate" scale="l" inline="true"></calcite-loader>
                        </div>
                    </div>
                    <p id="csvLink"></p>
                </calcite-block>
                <h3>Layers</h3>
                <div id="Layers">
                    <calcite-block collapsible close heading="Facilities" icon-start="layers" id="facilitiesBlock" >
                        <ul id="facilitiesLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Winter" icon-start="layers" id="winterBlock" >
                        <ul id="winterLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Infrastructure" icon-start="layers" id="infrastructureBlock">
                        <ul id="infrastructureLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Cultural Resource Management" icon-start="layers" id="crmBlock">
                        <ul id="crmLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Wildlife" icon-start="layers" id="wildlifeBlock">
                        <ul id="wildlifeLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Impact Assessment" icon-start="layers" id="iaBlock">
                        <ul id="iaLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Fire" icon-start="layers" id="fireBlock">
                        <ul id="fireLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="White Bark Pine" icon-start="layers" id="wbpBlock">
                        <ul id="wbpLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Vegetation" icon-start="layers" id="vegBlock">
                        <ul id="vegLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Vegetation Zones" icon-start="layers" id="vegzonesBlock">
                        <ul id="vegzonesLayerList" class="LayerBlock"></ul>
                    </calcite-block>

                    <calcite-block collapsible close heading="Hydrology" icon-start="layers" id="hydroBlock">
                        <ul id="hydroLayerList" class="LayerBlock"></ul>
                    </calcite-block>
                    <calcite-block collapsible close heading="Basemap" icon-start="layers" id="basemapBlock">
                        <ul id="basemapLayerList" class="LayerBlock"></ul>
                    </calcite-block>
                </div>
                <arcgis-features class="calcite-match-height" reference-element="#parks-map"></arcgis-features>
        </calcite-shell-panel>
        <calcite-panel  id="right-panel">
            <div id="mapContainer">
                <div id="exportFrameOverlay"></div>
                <div id="mapDiv"></div>
                <div id="resizeHandle"><calcite-icon icon="chevron-down" /><calcite-icon icon="chevron-up" /></div>
            </div>
            <div class="tabs" id="tabsContainer">
                <!-- Static Feature List Button -->
                <div class="tab-headers" id="tabHeaders">
                    <div class="tab-header static" id="featureListButton">
                        Feature List
                    </div>
                </div>
                
                <!-- Tab Contents -->
                <div class="tab-contents" id="tabContents">
                    <!-- Static Feature List Content -->
                    <div id="featureListTab" class="tab-content">
                        <div id="refresh">
                            <div id="refreshButton"><calcite-icon icon="refresh" scale="s"></calcite-icon> Refresh</div>
                        </div>
                        <div id="results">
                            <strong>Summary:</strong>
                            <div id="featureList"></div>
                        </div>
                    </div>
            
                    <!-- Dynamic Tabs will go here -->
                    <div id="dynamicTabs">
                        <!-- Dynamic tabs will be added dynamically here -->
                    </div>
                </div>
            </div>
        </calcite-panel>
    </calcite-shell>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
        const mapContainer = document.getElementById("mapContainer");
        const mapDiv = document.getElementById("mapDiv");
        const resizeHandle = document.getElementById("resizeHandle");
        let isResizing = false;

        resizeHandle.addEventListener("mousedown", function () {
            isResizing = true;
            document.body.style.cursor = "ns-resize";
        });

        document.addEventListener("mousemove", function (e) {
            if (!isResizing) return;

            const newHeight = e.clientY - mapContainer.getBoundingClientRect().top;

            if (newHeight > 200 && newHeight < window.innerHeight - 100) { // Min/max height
                mapContainer.style.height = `${newHeight}px`;
                mapDiv.style.height = `${newHeight}px`;
                window.view?.resize(); // Resize the Esri map if it's initialized
            }
        });

        document.addEventListener("mouseup", function () {
            isResizing = false;
            document.body.style.cursor = "default";
        });

        const featureListButton = document.getElementById('featureListButton');
        const featureListTab = document.getElementById('featureListTab');
    
        // Handle static Feature List button click
        featureListButton.addEventListener('click', function() {
            toggleFeatureListTab();
        });

        // Function to toggle the display of the Feature List tab
        function toggleFeatureListTab() {
            const featureListTab = document.getElementById('featureListTab');
            const featureListButton = document.getElementById('featureListButton');

            // Hide ALL tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; // Force-hide even Esri-rendered tables
            });

            // Remove active class from ALL headers
            document.querySelectorAll('.tab-header').forEach(header => {
                header.classList.remove('active');
            });

            // Activate Feature List
            featureListTab.classList.add('active');
            featureListTab.style.display = 'block'; // Make sure it shows
            featureListButton.classList.add('active');
        }

    });


    window.onload = function () {
        if (typeof window.jspdf !== "undefined") {
            console.log("jsPDF loaded successfully!");

            document.getElementById("exportPDFButton").addEventListener("click", function () {
                console.log("Export button clicked - starting PDF load function...");
                
                const loader = document.getElementById("pdfLoader");
                loader.style.display = "block"; // Show loader
                
                loadAndFillPDF().finally(() => {
                    loader.style.display = "none"; // Hide loader after export (even on error)
                });
            });

            async function loadAndFillPDF() {
                try {
                    if (!window.view) {
                        console.error("Esri MapView is not initialized yet.");
                        return;
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    
                    const templateUrl = "https://geo-x.apca2.gc.ca/apca/sharing/rest/content/items/d1c2cc29f3594b22be84be3d4c674fe3/data";
                    try {
                        console.log("Fetching PDF template from:", templateUrl);

                        // 1Ô∏è‚É£ Fetch the PDF template only once
                        const response = await fetch(templateUrl);
                        if (!response.ok) throw new Error("Failed to fetch PDF template.");
                        
                        const pdfBytes = await response.arrayBuffer();
                        const templatePdf = await PDFLib.PDFDocument.load(pdfBytes);
                        console.log("‚úÖ PDF template successfully loaded!");

                        // 2Ô∏è‚É£ Get Form Fields
                        const form = templatePdf.getForm();
                        const fields = form.getFields();
                        console.log("üìå Available form fields in template:", fields.map(f => f.getName()));

                        // 3Ô∏è‚É£ Fill Form Fields if available
                        const titleField = form.getTextField("titleField");
                        if (titleField) titleField.setText("Environmental Impact Report");
                        else console.warn("‚ö†Ô∏è Form field 'titleField' not found!");

                        const overlay = document.getElementById("exportFrameOverlay");
                        const mapDiv = window.view.container; // Esri MapView container

                        // Get overlay bounds relative to MapView
                        const overlayBounds = overlay.getBoundingClientRect();
                        const mapBounds = mapDiv.getBoundingClientRect();

                        // Calculate offset inside the MapView
                        const clipX = overlayBounds.left - mapBounds.left;
                        const clipY = overlayBounds.top - mapBounds.top;
                        const clipWidth = overlayBounds.width;
                        const clipHeight = overlayBounds.height;

                        console.log("üì∏ Screenshot area:", { clipX, clipY, clipWidth, clipHeight });

                        const imageScale = 10; // Try 2x or 3x for better resolution

                        const screenshot = await view.takeScreenshot({
                            area: {
                                x: clipX,
                                y: clipY,
                                width: clipWidth,
                                height: clipHeight
                            },
                            width: clipWidth * imageScale,
                            height: clipHeight * imageScale,
                            dpi: 300,
                            format: "png" // or "jpg"
                        });

                        const { rgb } = PDFLib;
                        let page = templatePdf.getPages()[0]; // Get the first page of the PDF template

                        // Check if the screenshot is PNG or JPG based on the data URL
                        const imageBytes = await fetch(screenshot.dataUrl).then(res => res.arrayBuffer());
                        
                        let image;
                        if (screenshot.dataUrl.startsWith('data:image/jpeg')) {
                            // If the screenshot is JPG, use embedJpg
                            image = await templatePdf.embedJpg(imageBytes);
                        } else if (screenshot.dataUrl.startsWith('data:image/png')) {
                            // If the screenshot is PNG, use embedPng
                            image = await templatePdf.embedPng(imageBytes);
                        } else {
                            throw new Error("Unsupported screenshot format. Only JPG and PNG are supported.");
                        }

                        // Define position and size for the map image
                        const x = 80;
                        const y = 210;  
                        const width = 400;
                        const height = 390;

                        // Step 3: Extract scale bar information
                        const scaleBarElement = document.querySelector(".esri-scale-bar__label");
                        const scaleBarLine = document.querySelector(".esri-scale-bar__line");

                        let scaleText = scaleBarElement ? scaleBarElement.textContent.trim() : "Scale: N/A";
                        let scaleWidthPx = scaleBarLine ? parseFloat(scaleBarLine.style.width) || 100 : 100;

                        console.log("Extracted scale bar label:", scaleText);
                        console.log("Extracted scale bar width (px):", scaleWidthPx);

                        const mapWidthPx = window.view.width; // The width of the map in pixels
                        const scaleFactor = width / mapWidthPx; // The ratio of map width in PDF points to map width in pixels
                        const scaleWidthPts = scaleWidthPx * scaleFactor; // Convert scale bar width to PDF points

                        console.log("Scale bar width in PDF points:", scaleWidthPts);

                        
                        // Step 1: Draw a border around the map image
                        page.drawRectangle({
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            color: rgb(0, 0, 0),  // Black color for the border
                            borderWidth: 4,       // Border thickness
                        });

                        // Step 2: Add the map screenshot (use PDFImage object)
                        page.drawImage(image, {
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                        });

                        // Step 4: Draw a Proportional Scale Bar
                        const scaleY = y - 10; // Position under the map
                        const scaleStartX = x + 10;
                        const scaleBarPDFWidth = scaleWidthPts; // Convert pixels to PDF units (approximate)


                        // Draw scale bar line
                        page.drawLine({
                            start: { x: scaleStartX, y: scaleY },
                            end: { x: scaleStartX + scaleBarPDFWidth, y: scaleY },
                            color: rgb(0, 0, 0),  // Black color for the scale bar line
                            width: 0.5,
                        });

                        // Draw end ticks for the scale bar
                        page.drawLine({
                            start: { x: scaleStartX, y: scaleY - 2 },
                            end: { x: scaleStartX, y: scaleY + 2 },
                            color: rgb(0, 0, 0),
                        });
                        page.drawLine({
                            start: { x: scaleStartX + scaleBarPDFWidth, y: scaleY - 2 },
                            end: { x: scaleStartX + scaleBarPDFWidth, y: scaleY + 2 },
                            color: rgb(0, 0, 0),
                        });

                        // Label the scale bar
                        page.setFontSize(10);
                        page.drawText(scaleText, {
                            x: scaleStartX + 24,
                            y: scaleY - 2,
                        });

                        // Define and draw North Arrow
                        const northArrowPath = "M 0 0 L -10 20 L 0 13 L 10 20 Z";

                        page.drawSvgPath(northArrowPath, { x: x + 15, y: y + height - 10, borderWidth: 1, color: rgb(0, 0, 0) });
                        page.setFontSize(12);
                        page.drawText("N", {
                            x: x + 10,
                            y: y + height - 40,
                        });

                        let yOffset = 130; // Start from the bottom of the first page

                        const columnSpacing = 150; 
                        const rowSpacing = 20;  
                        const maxRowsFirstPage = 5; // First page holds 5 rows

                        const featureListElements = document.getElementsByTagName("td");

                        // Draw table headers at the bottom of the first page
                        page.drawText("NAME", { x: 50, y: 150, size: 12 });
                        page.drawText("COUNT", { x: 200, y: 150, size: 12 });
                        page.drawText("AREA", { x: 350, y: 150, size: 12 });
                        page.drawText("LENGTH", { x: 500, y: 150, size: 12 });

                        for (let i = 0; i < featureListElements.length; i += 4) { // Process in groups of 4 (each row)
                            if (i / 4 === maxRowsFirstPage) {
                                // Add a second page when we exceed 5 rows
                                const newPage = templatePdf.addPage();
                                page = newPage;
                                yOffset = 750; // Start high on the second page
                            }

                            let xOffset = 50; // Reset to the first column position

                            for (let j = 0; j < 4; j++) { // Loop through NAME, COUNT, AREA, LENGTH columns
                                const text = featureListElements[i + j]?.innerText.trim() || "";
                                
                                page.drawText(text, {
                                    x: xOffset,
                                    y: yOffset,
                                    size: 10,
                                    color: PDFLib.rgb(0, 0, 0),
                                });

                                xOffset += columnSpacing; // Move to next column
                            }

                            yOffset -= rowSpacing; // Move down for next row
                        }

                        // Draw table headers at the bottom of the first page
                        page.drawText("NAME", { x: 50, y: 770, size: 12 });
                        page.drawText("COUNT", { x: 200, y: 770, size: 12 });
                        page.drawText("AREA", { x: 350, y: 770, size: 12 });
                        page.drawText("LENGTH", { x: 500, y: 770, size: 12 });


                        // Step 5: Save the modified PDF
                        form.flatten();
                        const modifiedPdfBytes = await templatePdf.save();
                        const pdfBlob = new Blob([modifiedPdfBytes], { type: "application/pdf" });
                        const blobUrl = URL.createObjectURL(pdfBlob);

                        // Open the PDF in a new tab
                        const newTab = window.open();
                        if (newTab) {
                            newTab.document.write(
                                `<html><body><embed width="100%" height="100%" src="${blobUrl}" type="application/pdf"></embed></body></html>`
                            );
                        } else {
                            console.error("Pop-up blocked! Unable to open new window.");
                            alert("Pop-up blocked! Please allow pop-ups for this site.");
                        }

                    
                    } catch (err) {
                        console.error("‚ùå PDF Export failed:", err);
                    }
                
                } catch (err) {
                    console.error("‚ùå PDF Export failed:", err);
                }
            }
       

            // Load the Esri API after jsPDF is ready
            const esriScript = document.createElement("script");
            esriScript.src = "https://js.arcgis.com/4.31/";
            esriScript.onload = function () {
                console.log("Esri ArcGIS API loaded!");

                require([
                    "esri/Map",
                    "esri/views/MapView",
                    "esri/layers/FeatureLayer",
                    "esri/layers/MapImageLayer",
                    "esri/layers/GroupLayer",
                    "esri/layers/support/Field",
                    "esri/layers/GraphicsLayer",
                    "esri/layers/KMLLayer",
                    "esri/layers/GeoJSONLayer",
                    "esri/geometry/geometryEngine",
                    "esri/geometry/Geometry",
                    "esri/geometry/Point",
                    "esri/geometry/Polyline",
                    "esri/geometry/Polygon",
                    "esri/geometry/SpatialReference",
                    "esri/geometry/operators/bufferOperator",
                    "esri/Graphic",
                    "esri/widgets/Sketch",
                    "esri/widgets/Sketch/SketchViewModel",
                    "esri/widgets/LayerList",
                    "esri/widgets/Legend",
                    "esri/widgets/Compass",
                    "esri/widgets/ScaleBar",
                    "esri/widgets/Features",
                    "esri/widgets/FeatureTable",
                    "esri/widgets/FeatureTable/FeatureTableViewModel",
                    "esri/widgets/FeatureTable/support/TableTemplate",
                    "esri/widgets/DistanceMeasurement2D",
                    "esri/symbols/SimpleFillSymbol",
                    "esri/symbols/SimpleLineSymbol",
                    "esri/symbols/SimpleMarkerSymbol",
                    "esri/support/actions/ActionButton",
                    "esri/core/Collection",
                ], function(Map, MapView, FeatureLayer, MapImageLayer, GroupLayer, Field, GraphicsLayer, KMLLayer, GeoJSONLayer, 
                                geometryEngine, Geometry, Point, Polyline, Polygon, SpatialReference, bufferOperator, Graphic, Sketch, SketchViewModel, LayerList, Legend, Compass, ScaleBar, Features, FeatureTable, FeatureTableVM, TableTemplate, DistanceMeasurement2D,
                                SimpleFillSymbol, SimpleLineSymbol, SimpleMarkerSymbol, ActionButton, Collection) {

                    const MIS = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Meadows_in_the_Sky_Parkway/FeatureServer/0",
                        outFields: ["*"],
                        title: "Meadows in the Sky Parkway",
                    });
                    
                    const Trails = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Facilities__Infrastructure/FeatureServer/3", 
                        outFields: ["*"], 
                        title: "Trails"
                    });

                    const LandParcels = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Land_Parcels/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Land Parcels",
                        visible: false,
                    });

                    const Facilities = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MRG_All_Facilities/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "All Facilities",
                    });

                    const RACS = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MRG_All_Facilities/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "RACS",
                    });

                    const TCH = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/TCHOneLine/FeatureServer/1", 
                        outFields: ["*"],  
                        title: "TCH",
                    });

                    const TCHNoStopping = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Avalanche_No_Stopping_Zones/FeatureServer/0", 
                        outFields: ["*"], 
                        title: "TCH No Stopping Zones",
                    });


                    const HeliStaging = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MRG_Helicopter_Staging/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Helicopter Staging",
                        visible: false,
                    });

                    const VRIStand = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/VRI_Stand_Age/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "VRI Stand Age",
                        visible: false,
                    });

                    const VETreed = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/VE_1240009_2/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Vegetation Zones - Treed",
                        visible: false,
                    });

                    const BCZones = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/BiogeoclimaticZones_MRG/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Biogeoclimatic Zones",
                        visible: false,
                    });

                    const GNPStream = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Hydrology/FeatureServer/0",
                        outFields: ["*"],  
                        title: "GNP Stream Order",
                        visible: false,
                    });

                    const MRStream = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Hydrology/FeatureServer/1", 
                        outFields: ["*"],  
                        title: "MR Stream Order",
                        visible: false,
                    });

                    const Ice = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Water_Ice/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Water & Ice",
                    });

                    const GNPArkyPoints = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/CRM___GNP_Archeological_Points/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "GNP Archeological Points",
                        visible: false,
                    });

                    const GNPArkyLines = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/CRM___GNP_Archeological_Lines/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "GNP Archeological Lines",
                        visible: false,
                    });

                    const GNPArkyAreas = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/CRM___GNP_Archeological_Areas/FeatureServer/0",
                        outFields: ["*"],  
                        title: "GNP Archeological Areas",
                        visible: false,
                    });

                    const RPHistoricPoints = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Historic_RP/FeatureServer/1", 
                        outFields: ["*"],  
                        title: "Rogers Pass Historic Infrastructure Points",
                        visible: false,
                    });

                    const AviPaths = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/AvalanchePaths/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Avalanche Paths",
                        visible: false,
                    });

                    const SkiTouring = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Ski_Touring_Routes/FeatureServer/0", 
                        outFields: ["*"], 
                        title: "Ski Touring Routes",
                        visible: false,
                    });

                    const FidelityRd = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Fidelity_Road/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Fidelity Road",
                    });

                    const Snowsheds = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/TCH_Snowsheds/FeatureServer/0",
                        outFields: ["*"],  
                        title: "TCH Snowsheds",
                    });

                    const GunPositions = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Gun_Positions/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Gun Positions",
                    });

                    const SnowNets = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/SnowNets/FeatureServer/0", 
                        outFields: ["*"], 
                        title: "Snow Nets",
                        visible: false,
                    });

                    const RarePlants = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Rare_Vascular_Plants_MIL1/MapServer", 
                        outFields: ["*"], 
                        title: "Rare Vascular Plants",
                        visible: false,
                    });

                    const Culverts = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Culverts_2021/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Culverts",
                        visible: false,
                    });

                    const Wells = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MonitoringWells_2024/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Monitoring Wells",
                        visible: false,
                    });

                    const StagingAreas = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/StagingAreas/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Staging Areas",
                        visible: false,
                    });

                    const ParkBoundary = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Mount_Revelstoke___Glacier_National_Park/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "MRG Park Boundary",
                    });

                    const FirePoints = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MRG_Fire_History_Fire_Points/FeatureServer/1", 
                        outFields: ["*"],  
                        title: "Fire Points",
                        visible: false,
                    });

                    const Lightning = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Burn_Probability_Lightning/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Ignitions - Lightning",
                        visible: false,
                    });

                    const BPHuman = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Burn_Probability_Human/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Ignitions - Human",
                        visible: false,
                    });

                    const BurnProb = new FeatureLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Burn_Probability/FeatureServer/0", 
                        outFields: ["*"],  
                        title: "Burn Probability",
                        visible: false,
                    });

                    const RPImagery = new MapImageLayer({
                        url: "https://geo-x.apca2.gc.ca/arcserver/rest/services/RogersPass_Imagery/MapServer",
                        title: "Rogers Pass Imagery (give it a sec to load in)",
                        visible: false,
                        sublayers: [
                        {
                            id: 3, // The sublayer index you want to show
                            visible: true
                        }
                        ]
                    });

                    
                    const allLayers = [Trails, LandParcels, RACS, TCHNoStopping, TCH, MIS, HeliStaging, GNPStream, MRStream, Ice, VRIStand, GNPArkyPoints, GNPArkyLines, GNPArkyAreas, RPHistoricPoints, AviPaths, SkiTouring, FidelityRd, Snowsheds, GunPositions, SnowNets,
                    VETreed, BCZones, RarePlants, Culverts, StagingAreas, ParkBoundary, Wells, FirePoints, Lightning, BPHuman, BurnProb
                    ];

                    
                    const layerFields = {
                        "Land Parcels": ["municipali"]
                    };

                    window.layerGroups = {
                        "Facilities": [Facilities, HeliStaging],
                        "Winter": [RACS, GunPositions, SnowNets, Snowsheds, SkiTouring, FidelityRd, TCHNoStopping, AviPaths],
                        "Wildlife": [],
                        "CRM": [GNPArkyPoints, RPHistoricPoints, GNPArkyLines, GNPArkyAreas],
                        "Infrastructure": [Trails, TCH, MIS, LandParcels],
                        "ImpactAssessment":[Culverts, StagingAreas, Wells],
                        "Fire":[FirePoints, Lightning, BPHuman, BurnProb],
                        "WhiteBarkPine":[],
                        "Veg": [RarePlants],
                        "VegZones": [VRIStand, BCZones, VETreed],                        
                        "Hydrology": [GNPStream, MRStream, Ice],
                        "Basemap": [ParkBoundary, RPImagery]
                    };
                    // Function to build the custom layer list
                    createCustomLayerList(layerGroups, Map);

                    

                    const map = new Map({
                    basemap: "topo-vector",
                    spatialReference: SpatialReference.WebMercator,
                    layers: [RPImagery , VRIStand, BCZones, VETreed, Lightning, BPHuman, BurnProb, Ice, AviPaths, GNPArkyAreas, GNPStream, MRStream, GNPArkyLines, LandParcels, TCHNoStopping, Snowsheds, TCH, Trails, SkiTouring, MIS, FidelityRd, RACS, HeliStaging, GunPositions, SnowNets, GNPArkyPoints, RPHistoricPoints, FirePoints,
                    Facilities, RarePlants, Culverts, StagingAreas, Wells, ParkBoundary]
                    });

                    const view = new MapView({
                    container: "mapDiv",
                    map: map,
                    center: [-118.1500, 51.4050],
                    zoom: 10
                    });

                    const scaleBar = new ScaleBar({
                        view: view
                    });
                   
                    view.ui.add(scaleBar, "bottom-left");

                    // Popup for the view
                    view.popup.autoOpenEnabled = true;  // Automatic opening of the popup when a feature is clicked
                    view.popup.defaultPopupTemplateEnabled = true; // Default template for popup
                    view.popup.dockEnabled = true;
                    view.popup.dockOptions = {
                        buttonEnabled: true,
                        breakpoint: false,
                        position: "top-right"  // ‚úÖ Options: top-right, top-left, bottom-right, bottom-left
                    };

                    const graphicsLayer = new GraphicsLayer({ id: "graphicsLayer" });
                    view.map.add(graphicsLayer);

                    // Sketch widget for drawing and editing
                    const sketch = new Sketch({
                        view: view,
                        layer: graphicsLayer,
                        availableTools: ["rectangle", "polygon"],
                        creationMode: "update", // Allow updating (editing) of existing geometries
                        visibleElements: {
                            selectionTools: {
                            "rectangle-selection": false,
                            "lasso-selection": false
                            }
                        }
                    });

                    view.ui.add(sketch, "top-left"); // Add Sketch widget to the view

                    document.getElementById("sketchContainer").appendChild(sketch.domNode);

                    sketch.on("create", function(event) {
                        console.log("‚úèÔ∏è Sketch create event triggered!");
                        console.log("üß™ Event:", event);
                        

                        if (event.state === "complete" && event.graphic) {
                            graphicsLayer.add(event.graphic); // ‚úÖ ensures export works
                            console.log("‚úÖ Sketch graphic added:", event.graphic);
                            console.log("Map has graphicsLayer?", map.layers.find(l => l.id === "graphicsLayer") !== undefined);
                            console.log("graphicsLayer.graphics.length:", graphicsLayer.graphics.length);
                            console.log("graphicsLayer.graphics:", graphicsLayer.graphics);
                        }
                    });
                    
                    sketch.on("update", function(event) {
                        console.log("‚úçÔ∏è Sketch update event triggered!");
                        console.log("Event type:", event.toolEventInfo && event.toolEventInfo.type);

                        if (event.graphics && event.graphics.length > 0) {
                            console.log("‚úÖ Sketch selected features!", event.graphics);

                            // Clear previous selection
                            selectedFeatures = [];

                            // Add new ones
                            event.graphics.forEach((g) => {
                                selectedFeatures.push(g);
                            });

                            console.log("‚úÖ Updated selectedFeatures from sketch:", selectedFeatures);
                        }
                    });

                    

                    let selectedFeatures = []; // Store selected features
                    let highlight; // Global variable to track current highlight

                    view.on("click", function(event) {
                        console.log("üñ±Ô∏è Map clicked at:", event.mapPoint);

                        view.hitTest(event).then(function(response) {
                            if (response.results.length > 0) {
                                const graphic = response.results[0].graphic;
                                console.log("‚úÖ A feature was clicked!", graphic.attributes);

                                // If not holding Shift, clear previous selection
                                if (!event.native.shiftKey) {
                                    selectedFeatures = []; // üßπ Clear the array
                                    if (highlight) {
                                        highlight.remove();
                                        highlight = null;
                                    }
                                }

                                // Prevent duplicates if shift-clicking the same feature again
                                const alreadySelected = selectedFeatures.some((g) => g === graphic);
                                if (!alreadySelected) {
                                    selectedFeatures.push(graphic);
                                }

                                console.log("‚úÖ Updated selected features:", selectedFeatures);
                                console.log("üìã featureTables contents:", featureTables);

                                // üîÑ Sync map selection TO attribute table
                                Object.values(featureTables).forEach((table) => {
                                    
                                    if (table.layer !== graphic.layer) {
                                        table.clearSelection();  // only clear other layers
                                        console.log("cleared");
                                        return;
                                    }

                                    const objectIdField = table.layer.objectIdField || "OBJECTID";
                                    const objectId = graphic.attributes[objectIdField];

                                    if (objectId == null) {
                                        console.warn("‚ö†Ô∏è No OBJECTID found on graphic:", graphic.attributes);
                                        return;
                                    }

                                    table.layer.queryFeatures({
                                        objectIds: [objectId],
                                        outFields: ["*"],
                                        returnGeometry: false
                                    }).then((result) => {
                                        if (result.features.length > 0) {
                                        const feature = result.features[0];
                                        table.selectRows([feature]);  // ‚úÖ properly selects row
                                        } else {
                                        console.warn("‚ö†Ô∏è No matching feature found for OBJECTID:", objectId);
                                        }
                                    });
                                });

                                const layer = graphic.layer;
                                    if (!layer) {
                                        console.warn("‚ùó Graphic has no layer ‚Äì skipping highlight");
                                        return;
                                    }

                                    view.whenLayerView(layer).then(function(layerView) {
                                        if (highlight) highlight.remove();
                                        highlight = layerView.highlight(selectedFeatures);
                                    }).catch((error) => {
                                    console.warn("‚ö†Ô∏è Couldn't get layer view for highlight:", error);
                                    });

                            } else {
                                console.log("‚ùå No feature found at this point");

                                // Clear selection if clicked on empty space (and not shift-clicking)
                                if (!event.native.shiftKey) {
                                    if (highlight) {
                                        highlight.remove();
                                        highlight = null;
                                    }
                                    selectedFeatures = [];
                                }
                            }
                        });
                    });


                    let layerCounter = 1;

                    function createLayerFromSelectedFeatures() {
                        if (selectedFeatures.length === 0) {
                            console.error("‚ùå No features selected.");
                            return;
                        }

                        const defaultLayerName = `Layer ${layerCounter++}`;
                        const newGraphicsLayer = new GraphicsLayer();

                        selectedFeatures.forEach((feature) => {
                            const graphic = new Graphic({
                                geometry: feature.geometry,
                                attributes: feature.attributes,
                                symbol: feature.symbol
                            });
                            newGraphicsLayer.add(graphic);
                        });

                        const graphicsArray = newGraphicsLayer.graphics.toArray();
                        const firstGraphic = graphicsArray[0];

                        if (!firstGraphic || !firstGraphic.geometry) {
                            console.error("‚ùå Invalid graphic.");
                            return;
                        }

                        const newFeatureLayer = new FeatureLayer({
                            title: defaultLayerName,
                            source: graphicsArray,
                            objectIdField: "OBJECTID",
                            fields: [{ name: "OBJECTID", type: "oid" }],
                            geometryType: firstGraphic.geometry.type,
                            spatialReference: view.spatialReference
                        });
                        newFeatureLayer._originalGraphics = graphicsArray;

                        view.map.add(newFeatureLayer);
                        addLayerToList(newFeatureLayer);
                    }

                    function addLayerToList(layer) {
                        const uploadedLayersList = document.getElementById("uploadedLayersList");

                        const listItem = document.createElement("li");
                        listItem.classList.add("importLi");
                        
                        const leftSection = document.createElement("div");
                        leftSection.classList.add("liLeft");
                        
                        // üëÅÔ∏è Visibility checkbox
                        const visibilityCheckbox = document.createElement("input");
                        visibilityCheckbox.type = "checkbox";
                        visibilityCheckbox.checked = true;
                        visibilityCheckbox.title = "Toggle visibility";
                        visibilityCheckbox.addEventListener("change", () => {
                            layer.visible = visibilityCheckbox.checked;
                        });

                        // üè∑Ô∏è Layer name & rename input
                        const nameContainer = document.createElement("div");
                        nameContainer.style.flex = "1";

                        const nameLabel = document.createElement("span");
                        nameLabel.textContent = layer.title;
                        nameLabel.style.cursor = "default";

                        const nameInput = document.createElement("input");
                        nameInput.type = "text";
                        nameInput.value = layer.title;
                        nameInput.style.display = "none";
                        nameInput.style.width = "100%";

                        nameInput.addEventListener("keydown", (e) => {
                            if (e.key === "Enter") {
                                const newName = nameInput.value.trim();
                                if (newName) {
                                    layer.title = newName;
                                    nameLabel.textContent = newName;
                                }
                                nameInput.style.display = "none";
                                nameLabel.style.display = "inline";
                            }
                        });

                        nameContainer.appendChild(nameLabel);
                        nameContainer.appendChild(nameInput);

                        leftSection.appendChild(visibilityCheckbox);
                        leftSection.appendChild(nameLabel);
                        leftSection.appendChild(nameContainer);

                        const rightSection = document.createElement("div");
                        rightSection.classList.add("liRight");

                        // ‚ãØ Ellipsis button
                        const menuWrapper = document.createElement("div");
                        menuWrapper.style.position = "relative";

                        const menuButton = document.createElement("div");
                        menuButton.style.padding = "0px 5px 5px 0px" ;
                        menuButton.style.cursor = "pointer";
                        menuButton.style.display = "flex";
                        menuButton.style.alignItems = "center";
                        menuButton.style.gap = "35px"; // spacing between icon and any label (if needed)

                        const menuIcon = document.createElement("calcite-icon");
                        menuIcon.setAttribute("icon", "ellipsis-circle");
                        menuIcon.setAttribute("scale", "m"); // optional: s, m, l
                        menuIcon.style.padding = "0px 5px 3px 0px";

                        menuButton.appendChild(menuIcon);

                        // Dropdown menu (inside list item)
                        const menu = document.createElement("div");
                        menu.style.display = "none";
                        menu.style.position = "absolute";
                        menu.style.top = "24px";
                        menu.style.right = "0";
                        menu.style.background = "#fff";
                        menu.style.border = "1px solid #ccc";
                        menu.style.padding = "5px 0";
                        menu.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
                        menu.style.zIndex = "10";
                        menu.style.minWidth = "100px";

                        // üìù Rename option
                        const renameOption = document.createElement("div");
                        renameOption.textContent = "Rename";
                        renameOption.style.padding = "5px 10px";
                        renameOption.style.cursor = "pointer";
                        renameOption.addEventListener("click", () => {
                            nameLabel.style.display = "none";
                            nameInput.style.display = "inline";
                            nameInput.focus();
                            menu.style.display = "none";
                        });

                        // üóëÔ∏è Delete option with icon
                        const deleteOption = document.createElement("div");
                        deleteOption.classList.add("deleteOption");

                        const trashIcon = document.createElement("calcite-icon");
                        trashIcon.setAttribute("icon", "trash");
                        trashIcon.setAttribute("scale", "s"); // optional: s, m, l
                        trashIcon.setAttribute("text-label", "Delete layer");

                        deleteOption.appendChild(trashIcon);

                        deleteOption.addEventListener("click", () => {
                            view.map.remove(layer);
                            listItem.remove();
                            console.log(`üßπ Removed layer: ${layer.title}`);
                        });

                        // Export Option
                        const exportOption = document.createElement("div");
                        exportOption.textContent = "Export";
                        exportOption.style.padding = "5px 10px";
                        exportOption.style.cursor = "pointer";
                        exportOption.addEventListener("click", () => {
                            exportGeometry("kml", layer);
                            console.log(`üßπ exported layer: ${layer.title}`);
                        });

                        menu.appendChild(renameOption);
                        menu.appendChild(exportOption);
                        menuWrapper.appendChild(menuButton);
                        menuWrapper.appendChild(menu);

                        // Toggle dropdown visibility
                        menuButton.addEventListener("click", (e) => {
                            e.stopPropagation(); // prevent window click from hiding it
                            menu.style.display = menu.style.display === "block" ? "none" : "block";
                        });

                        // Hide dropdown on outside click
                        window.addEventListener("click", () => {
                            menu.style.display = "none";
                        });

                        rightSection.appendChild(menuWrapper)
                        rightSection.appendChild(deleteOption)
                        
                        listItem.appendChild(leftSection);
                        listItem.appendChild(rightSection);
                        uploadedLayersList.appendChild(listItem);
                    }

                    // Call the function to create a new layer when needed
                    document.getElementById("createLayerButton").addEventListener("click", () => {
                        createLayerFromSelectedFeatures();
                        console.log("Layer Created");
                    });

                    document.getElementById("uploadButton").addEventListener("click", function() {
                        document.getElementById("fileInput").click();
                        console.log("upload initiated");
                    });

 
                    document.getElementById("fileInput").addEventListener("change", function (event) {
                        const file = event.target.files[0];
                        if (file) {
                            handleFileUpload(file);
                        }
                    });

                    function initializeFileUploadHandler() {
                        require([
                            "esri/layers/FeatureLayer",
                            "esri/geometry/Point",
                            "esri/geometry/Polyline",
                            "esri/geometry/Polygon",
                            "esri/Graphic",
                            "esri/geometry/SpatialReference",
                            "esri/layers/support/Field"
                        ], function (FeatureLayer, Point, Polyline, Polygon, Graphic, SpatialReference, Field) {
                            const uploadedLayersList = document.getElementById("uploadedLayersList");
                            const uploadedLayers = {}; // Store layers by filename

                            document.getElementById("fileInput").addEventListener("change", function (event) {
                                const file = event.target.files[0];
                                if (file) {
                                    handleFileUpload(file);
                                }
                            });

                            async function handleFileUpload(file) {
                                const reader = new FileReader();

                                reader.onload = async function (event) {
                                    console.log("File read successfully");

                                    let geojson;
                                    try {
                                        geojson = await parseGeoJSON(file, event.target.result);
                                    } catch (error) {
                                        console.error("Error processing file:", error);
                                        return;
                                    }

                                    if (!geojson || !geojson.features.length) {
                                        console.error("No valid features found in GeoJSON.");
                                        return;
                                    }

                                    addGeoJSONToMap(geojson, file.name);
                                };

                                if (file.name.endsWith(".kmz")) {
                                    reader.readAsArrayBuffer(file);
                                } else {
                                    reader.readAsText(file);
                                }
                            }

                            async function parseGeoJSON(file, fileContent) {
                                const parser = new DOMParser();
                                let geojson;

                                if (file.name.endsWith(".gpx")) {
                                    const gpxXml = parser.parseFromString(fileContent, "application/xml");
                                    geojson = toGeoJSON.gpx(gpxXml);
                                } else if (file.name.endsWith(".kml")) {
                                    const kmlXml = parser.parseFromString(fileContent, "application/xml");
                                    geojson = toGeoJSON.kml(kmlXml);
                                } else if (file.name.endsWith(".kmz")) {
                                    geojson = await convertKMZToGeoJSON(fileContent);
                                } else {
                                    throw new Error("Unsupported file format.");
                                }

                                return geojson;
                            }

                            async function convertKMZToGeoJSON(arrayBuffer) {
                                const zip = await JSZip.loadAsync(arrayBuffer);
                                let kmlFile;

                                for (const fileName in zip.files) {
                                    if (fileName.endsWith(".kml")) {
                                        kmlFile = zip.files[fileName];
                                        break;
                                    }
                                }

                                if (!kmlFile) {
                                    throw new Error("No KML file found inside KMZ.");
                                }

                                const kmlText = await kmlFile.async("text");
                                const parser = new DOMParser();
                                const kmlXml = parser.parseFromString(kmlText, "application/xml");

                                return toGeoJSON.kml(kmlXml);
                            }

                            function addGeoJSONToMap(geojson, fileName) {
                                console.log("Adding to map:", geojson);

                                const fields = extractFieldsFromGeoJSON(geojson);
                                const graphics = [];

                                geojson.features.forEach(feature => {
                                    let geometry;
                                    if (feature.geometry.type === "MultiLineString" || feature.geometry.type === "LineString") {
                                        geometry = new Polyline({
                                            paths: feature.geometry.coordinates
                                        });
                                    } else if (feature.geometry.type === "Polygon") {
                                        geometry = new Polygon({
                                            rings: feature.geometry.coordinates
                                        });
                                    } else if (feature.geometry.type === "Point") {
                                        geometry = new Point({
                                            latitude: feature.geometry.coordinates[1],
                                            longitude: feature.geometry.coordinates[0]
                                        });
                                    }

                                    const graphic = new Graphic({
                                        geometry: geometry,
                                        attributes: feature.properties
                                    });

                                    graphics.push(graphic);
                                });

                                // Create FeatureLayer
                                const featureLayer = new FeatureLayer({
                                    source: graphics,
                                    fields: fields,
                                    objectIdField: "ObjectID",
                                    spatialReference: SpatialReference.WGS84,
                                    title: fileName, // Store the file name as the title
                                    visible: true // Set layer to be visible by default
                                });

                                map.add(featureLayer);
                                uploadedLayers[fileName] = featureLayer; // Store layer reference
                                allLayers.push(featureLayer); // ‚úÖ Add uploaded layers to queryable layers
                                layerFields[fileName] = fields.map(field => field.name); // ‚úÖ Store fields for query

                                // Update the UI list with a toggle checkbox
                                updateUploadedLayersList(fileName);
                            }

                            function extractFieldsFromGeoJSON(geojson) {
                                const fields = [{ name: "ObjectID", alias: "Object ID", type: "oid" }];
                                geojson.features.forEach(feature => {
                                    Object.keys(feature.properties).forEach(key => {
                                        if (!fields.some(field => field.name === key)) {
                                            fields.push({ name: key, alias: key, type: "string" });
                                        }
                                    });
                                });
                                return fields;
                            }

                            function updateUploadedLayersList(fileName) {
                                const listItem = document.createElement("li");
                                listItem.classList.add("importLi");

                                // Left side: checkbox + label container
                                const leftSection = document.createElement("div");
                                leftSection.classList.add("liLeft");

                                const checkbox = document.createElement("input");
                                checkbox.type = "checkbox";
                                checkbox.checked = true;
                                checkbox.addEventListener("change", function () {
                                    uploadedLayers[fileName].visible = checkbox.checked;
                                });

                                const label = document.createElement("span");
                                label.textContent = fileName;

                                leftSection.appendChild(checkbox);
                                leftSection.appendChild(label);

                                const rightSection = document.createElement("div");
                                rightSection.classList.add("liRight");

                                // Right side: trash icon
                                const deleteOption = document.createElement("div");
                                deleteOption.classList.add("deleteOption");

                                const trashIcon = document.createElement("calcite-icon");
                                trashIcon.setAttribute("icon", "trash");
                                trashIcon.setAttribute("scale", "s");
                                trashIcon.setAttribute("text-label", "Delete layer");

                                deleteOption.appendChild(trashIcon);

                                deleteOption.addEventListener("click", () => {
                                    view.map.remove(uploadedLayers[fileName]);
                                    listItem.remove();
                                    console.log(`üßπ Removed layer: ${uploadedLayers[fileName]}`);
                                });

                                rightSection.appendChild(deleteOption);

                                // Append both sections to list item
                                listItem.appendChild(leftSection);
                                listItem.appendChild(rightSection);
                                uploadedLayersList.appendChild(listItem);
                            }

                        });
                    }

                    initializeFileUploadHandler();


                    function createCustomLayerList(layerGroups, view) {
                        const facilitiesBlock = document.querySelector("#facilitiesBlock");
                        const winterBlock = document.querySelector("#winterBlock");
                        const wildlifeBlock = document.querySelector("#wildlifeBlock");
                        const crmBlock = document.querySelector("#crmBlock");
                        const infrastructureBlock = document.querySelector("#infrastructureBlock");
                        const iaBlock = document.querySelector("#iaBlock");
                        const fireBlock = document.querySelector("#fireBlock");
                        const wbpBlock = document.querySelector("#wbpBlock");
                        const vegBlock = document.getElementById("vegBlock");
                        const vegzonesBlock = document.getElementById("vegzonesBlock");
                        const hydroBlock = document.getElementById("hydroBlock");
                        const basemapBlock = document.getElementById("basemapBlock");

                        const facilitiesList = document.getElementById("facilitiesLayerList");
                        const winterList = document.getElementById("winterLayerList");
                        const wildlifeList = document.getElementById("wildlifeLayerList");
                        const crmList = document.getElementById("crmLayerList");
                        const infrastructureList = document.getElementById("infrastructureLayerList");
                        const iaList = document.getElementById("iaLayerList");
                        const fireList = document.getElementById("fireLayerList");
                        const wbpList = document.getElementById("wbpLayerList");
                        const vegList = document.getElementById("vegLayerList");
                        const vegzonesList = document.getElementById("vegzonesLayerList");
                        const hydroList = document.getElementById("hydroLayerList");
                        const basemapList = document.getElementById("basemapLayerList");
 
                        function getSymbolUrl(symbol) {
                            if (!symbol) return "";

                            // If it's an image-based symbol (e.g., picture-marker)
                            if (symbol.url) {
                                return symbol.url;
                            }

                            if (symbol.type === "simple-marker") {
                                return getSimpleMarkerSymbol(symbol);
                            }
                            // Handle simple line symbols directly
                            else if (symbol.type === "simple-line") {
                                return getSimpleLineSymbol(symbol);
                            }
                            // Handle simple fill symbols directly
                            else if (symbol.type === "simple-fill") {
                                return getSimpleFillSymbol(symbol);
                            }

                            return "";  // Fallback if the symbol is unsupported
                        }

                        function getSimpleMarkerSymbol(symbol) {
                            const fillColor = symbol.color || {r: 0, g: 0, b: 0, a: 1};
                            const outlineColor = symbol.outline ? symbol.outline.color : { r: 0, g: 0, b: 0, a: 1 }; // Default black outline
                            const outlineWidth = symbol.outline && symbol.outline.width > 1 ? symbol.outline.width : 1; // Default outline width
                            const size = symbol.size || 4;
                            const style = symbol.style || "circle";

                            // Convert RGBA to proper CSS rgba format
                            const rgbaFillColor = `rgba(${fillColor.r}, ${fillColor.g}, ${fillColor.b}, ${fillColor.a})`;
                            const rgbaOutlineColor = `rgba(${outlineColor.r}, ${outlineColor.g}, ${outlineColor.b}, ${outlineColor.a})`;

                            let shape = '';
                            if (style === "circle") {
                                shape = `<circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="rgba(${fillColor[0]}, ${fillColor[1]}, ${fillColor[2]}, ${fillColor[3] / 255})"/>`;
                            } else if (style === "square") {
                                shape = `<rect width="${size}" height="${size}" fill="rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})"/>`;
                            }

                            // Generate SVG for simple marker
                            return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='${rgbaFillColor}' stroke='${rgbaOutlineColor}' stroke-width='${outlineWidth}' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>${shape}%3C/svg%3E`;
                        }

                        function getSimpleLineSymbol(symbol) {
                            // Check if color is a simple object with r, g, b, a components
                            const color = symbol.color || {r: 0, g: 0, b: 0, a: 1}; // Default to black with full opacity if missing
                            const width = symbol.width && symbol.width > 1 ? symbol.width : 4;

                            // Ensure we're using the r, g, b, a components from the color object
                            const rgbaColor = `rgba(${color.r || 0}, ${color.g || 0}, ${color.b || 0}, ${color.a || 1})`;


                            // Generate the SVG data URL for the line symbol
                            return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cline x1='50' y1='15' x2='-50' y2='15' stroke='${rgbaColor}' stroke-width='${width}' /%3E%3C/svg%3E`;
                        }

                        // For simple-fill symbols
                        function getSimpleFillSymbol(symbol) {
                            // Default color and outline
                            const fillColor = symbol.color || { r: 0, g: 0, b: 0, a: 1 }; // Default to black with full opacity
                            const outlineColor = symbol.outline ? symbol.outline.color : { r: 0, g: 0, b: 0, a: 0 }; // Default black outline
                            const outlineWidth = symbol.outline && symbol.outline.width > 1 ? symbol.outline.width : 4; // Default outline width

                            // Convert RGBA to proper CSS rgba format
                            const rgbaFillColor = `rgba(${fillColor.r}, ${fillColor.g}, ${fillColor.b}, ${fillColor.a})`;
                            const rgbaOutlineColor = `rgba(${outlineColor.r}, ${outlineColor.g}, ${outlineColor.b}, ${outlineColor.a})`;

                            // Creating a simple rectangle polygon (you can adjust the shape later)
                            return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E
                                    %3Cpolygon points='5,5 25,5 25,25 5,25' fill='${rgbaFillColor}' stroke='${rgbaOutlineColor}' stroke-width='${outlineWidth}' /%3E
                                    %3C/svg%3E`;
                        }

                        function displayLayerSymbology(layer, container) {
                            layer.when(() => {
                                if (!layer.renderer) {
                                    console.warn(`No renderer found for layer: ${layer.title}`);
                                    return;
                                }

                            container.innerHTML = "";  // Clear previous symbology

                            const renderer = layer.renderer;

                            // For simple symbols
                            if (renderer.symbol) {
                                const symbolUrl = getSymbolUrl(renderer.symbol);
                                if (symbolUrl) {
                                    const symbolDiv = createSymbolLegend(symbolUrl);
                                    container.appendChild(symbolDiv);
                                }
                            }
                            else if (renderer.uniqueValueInfos) {
                                const uniqueLabels = {};

                                renderer.uniqueValueInfos.forEach(info => {
                                    const label = info.label || info.value || "Unnamed";

                                    // Only add if we haven't already stored a symbol for this label
                                    if (!uniqueLabels[label]) {
                                        uniqueLabels[label] = info.symbol;
                                    }
                                });

                                // Render one symbol per unique label
                                Object.keys(uniqueLabels).forEach(label => {
                                    const symbol = uniqueLabels[label];
                                    const symbolUrl = getSymbolUrl(symbol);
                                    if (symbolUrl) {
                                        const symbolDiv = createSymbolLegend(symbolUrl, label);
                                        container.appendChild(symbolDiv);
                                    }
                                });
                            }
                            // For class breaks renderer
                            else if (renderer.classBreakInfos) {
                                renderer.classBreakInfos.forEach(info => {
                                    const symbolUrl = getSymbolUrl(info.symbol);
                                    if (symbolUrl) {
                                        const symbolDiv = createSymbolLegend(symbolUrl, `Range: ${info.minValue} - ${info.maxValue}`);
                                        container.appendChild(symbolDiv);
                                    }
                                });
                            } else {
                                console.warn(`No supported renderer type for layer: ${layer.title}`);
                            }
                            }).catch(error => {
                                console.error(`Error loading layer: ${layer.title}`, error);
                            });
                        }

                        function createSymbolLegend(symbolUrl, label) {
                            const symbolDiv = document.createElement("div");
                            symbolDiv.style.display = "flex";
                            symbolDiv.style.marginRight = "5px";

                            const img = document.createElement("img");
                            img.src = symbolUrl;  // Set the image source to the symbol URL
                            img.style.width = "20px";
                            img.style.height = "20px";
                            img.style.marginRight = "5px";
                            

                            const text = document.createElement("span");
                            text.textContent = label; // Display label or "Default"

                            symbolDiv.appendChild(img);
                            symbolDiv.appendChild(text);

                            return symbolDiv;
                        }

                        function addGroupToggleSwitch(block, layers, title) {
                            const switchToggle = document.createElement("calcite-switch");
                            switchToggle.setAttribute("scale", "s");
                            switchToggle.style.marginLeft = "8px";

                            const actionContainer = document.createElement("calcite-action");
                            actionContainer.setAttribute("slot", "control");
                            actionContainer.appendChild(switchToggle);
                            block.appendChild(actionContainer);

                            // Set initial checked state: ON if any layer is visible
                            switchToggle.checked = layers.some(layer => layer.visible);

                            // Function to update the group switch based on current layer states
                            function updateGroupSwitch() {
                                switchToggle.checked = layers.some(l => l.visible);
                            }

                            // When group switch is toggled, update all layers + their toggles
                            switchToggle.addEventListener("calciteSwitchChange", function () {
                                const newVisibility = switchToggle.checked;
                                layers.forEach(layer => {
                                    layer.visible = newVisibility;

                                    // Update corresponding toggle
                                    const toggleEl = document.querySelector(`#toggle-${layer.id}`);
                                    if (toggleEl) toggleEl.checked = newVisibility;
                                });
                            });

                            // When individual layers change, update the group toggle
                            layers.forEach(layer => {
                                layer.watch("visible", () => {
                                    updateGroupSwitch();

                                    const toggleEl = document.querySelector(`#toggle-${layer.id}`);
                                    if (toggleEl) toggleEl.checked = layer.visible;
                                });
                            });

                            // Initial sync of individual toggles if they exist
                            layers.forEach(layer => {
                                const toggleEl = document.querySelector(`#toggle-${layer.id}`);
                                if (toggleEl) {
                                    toggleEl.checked = layer.visible;

                                    toggleEl.addEventListener("calciteSwitchChange", () => {
                                        layer.visible = toggleEl.checked;
                                    });
                                }
                            });
                        }


                        // Function to create layer toggle button for each individual layer
                        function createLayerToggleButton(layer, container) {
                            const li = document.createElement("li");
                            li.style.listStyle = "none";
                            li.style.marginTop = "30px"; // Consistent spacing from the title
                            li.style.display = "flex";
                            li.style.justifyContent = "flex-start"; // Align to the left
                            li.style.flexDirection = "row";
                            li.style.width = "100%";
                            li.style.marginLeft = "0px";
                            li.style.marginRight = "0px";

                            // Table Icon - Click to open attribute table
                            const tableIcon = document.createElement("calcite-icon");
                            tableIcon.setAttribute("icon", "table");
                            tableIcon.setAttribute("scale", "s");
                            tableIcon.style.cursor = "pointer";
                            tableIcon.style.marginRight = "10px";
                            tableIcon.title = `Open ${layer.title} Table`;

                            // Open table in new tab when clicked
                            tableIcon.addEventListener("click", function () {
                                openAttributeTable(layer);
                            });

                            const label = document.createElement("layerLabel");
                            label.textContent = layer.title;
                            label.style.width = "130px";
                            label.style.fontWeight = "bold";

                            // Add symbology under each layer
                            const symbologyContainer = document.createElement("SymbolDiv");
                            symbologyContainer.style.flexDirection = "column";
                            symbologyContainer.style.display = "flex"; // Align symbols in a row
                            symbologyContainer.style.alignItems = "right"; // Align symbols vertically
                            symbologyContainer.style.justifyContent = "flex-start"; // Align symbols to the left
                            symbologyContainer.style.marginLeft = "20px"; // Consistent spacing from the title
                            symbologyContainer.style.marginRight = "18px";
                            symbologyContainer.style.gap = "7px"; 
                            symbologyContainer.style.maxHeight = "400px";
                            symbologyContainer.style.width = "240px";
                            symbologyContainer.style.overflowY = "scroll";
                            symbologyContainer.style.overflow = "auto";
                            symbologyContainer.style.overflowx = "hidden";

                            displayLayerSymbology(layer, symbologyContainer);

                           
                            const switchToggle = document.createElement("calcite-switch");
                            switchToggle.setAttribute("scale", "s");
                            switchToggle.setAttribute("id", `toggle-${layer.id}`);
                            switchToggle.checked = layer.visible;

                            // Event listener for toggling visibility
                            switchToggle.addEventListener("calciteSwitchChange", function () {
                                layer.visible = switchToggle.checked;
                                console.log(`Layer ${layer.title} visibility: ${layer.visible}`);
                            });

                            // Append elements in order
                            li.appendChild(tableIcon);
                            li.appendChild(label); 
                            li.appendChild(symbologyContainer);
                            li.appendChild(switchToggle);

                            // Add to container
                            container.appendChild(li);
                            container.style.padding = "0";
                            container.style.margin = "0";
                            container.style.textAlign = "left";
                            container.style.display = "flex";
                            container.style.flexDirection = "column";
                            container.style.alignItems = "flex-start";
                        }

                        // Add Group Toggles to Blocks (Now inside heading)
                        addGroupToggleSwitch(facilitiesBlock, layerGroups["Facilities"], "Facilities");
                        addGroupToggleSwitch(winterBlock, layerGroups["Winter"], "Winter");
                        addGroupToggleSwitch(wildlifeBlock, layerGroups["Wildlife"], "Wildlife");
                        addGroupToggleSwitch(crmBlock, layerGroups["CRM"], "CRM");
                        addGroupToggleSwitch(infrastructureBlock, layerGroups["Infrastructure"], "Infrastructure");
                        addGroupToggleSwitch(iaBlock, layerGroups["ImpactAssessment"], "ImpactAssessment");
                        addGroupToggleSwitch(fireBlock, layerGroups["Fire"], "Fire");
                        addGroupToggleSwitch(wbpBlock, layerGroups["WhiteBarkPine"], "WhiteBarkPine");
                        addGroupToggleSwitch(vegBlock, layerGroups["Veg"], "Veg");
                        addGroupToggleSwitch(vegzonesBlock, layerGroups["VegZones"], "VegZones");
                        addGroupToggleSwitch(hydroBlock, layerGroups["Hydrology"], "Hydrology");
                        addGroupToggleSwitch(basemapBlock, layerGroups["Basemap"], "Basemap");

                        // Populate Layer List
                        layerGroups["Facilities"].forEach(layer => createLayerToggleButton(layer, facilitiesList));
                        layerGroups["Winter"].forEach(layer => createLayerToggleButton(layer, winterList));
                        layerGroups["Wildlife"].forEach(layer => createLayerToggleButton(layer, wildlifeList));
                        layerGroups["CRM"].forEach(layer => createLayerToggleButton(layer, crmList));
                        layerGroups["Infrastructure"].forEach(layer => createLayerToggleButton(layer, infrastructureList));
                        layerGroups["ImpactAssessment"].forEach(layer => createLayerToggleButton(layer, iaList));
                        layerGroups["Fire"].forEach(layer => createLayerToggleButton(layer, fireList));
                        layerGroups["WhiteBarkPine"].forEach(layer => createLayerToggleButton(layer, wbpList));
                        layerGroups["Veg"].forEach(layer => createLayerToggleButton(layer, vegList));
                        layerGroups["VegZones"].forEach(layer => createLayerToggleButton(layer, vegzonesList));
                        layerGroups["Hydrology"].forEach(layer => createLayerToggleButton(layer, hydroList));
                        layerGroups["Basemap"].forEach(layer => createLayerToggleButton(layer, basemapList));
                    }
                    
                    const featureTables = {};
                    const layerTabMap = {};  // <== NEW: layer.id => tabId
                    let tabCount = 1;
                    let draggedIndex = null;

                    function openAttributeTable(layer) {
                        if (layerTabMap[layer.id]) {
                            // Tab already exists, just select it
                            selectTab(layerTabMap[layer.id]);
                            return;
                        }

                        const tabId = 'tab-' + tabCount++;
                        layerTabMap[layer.id] = tabId; // track it

                        const header = document.createElement('div');
                        header.className = 'tab-header';
                        header.innerHTML = `${layer.title} `;
                        header.setAttribute('data-tab-id', tabId);

                        header.addEventListener('click', () => {
                            selectTab(tabId);
                        });

                        const closeIcon = document.createElement('calcite-icon');
                        closeIcon.setAttribute('icon', 'x');
                        closeIcon.setAttribute('scale', 's');
                        closeIcon.classList.add('close-btn');
                        closeIcon.style.cursor = 'pointer';
                        closeIcon.addEventListener('click', (event) => {
                            closeTab(tabId, layer.id, event);
                        });
                        header.appendChild(closeIcon);

                        // drag behavior
                        header.draggable = true;
                        header.addEventListener("dragstart", (e) => {
                            draggedIndex = Array.from(header.parentNode.children).indexOf(header);
                        });
                        header.addEventListener("dragover", (e) => e.preventDefault());
                        header.addEventListener("drop", (e) => {
                            e.preventDefault();
                            const headers = document.getElementById("tabHeaders");
                            const all = Array.from(headers.children);
                            const dropIndex = all.indexOf(header);
                            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                                const dragged = all[draggedIndex];
                                headers.insertBefore(dragged, dropIndex > draggedIndex ? header.nextSibling : header);
                            }
                        });

                        const content = document.createElement('div');
                        content.className = 'tab-content';
                        content.id = tabId;

                        const tableContainer = document.createElement('div');
                        tableContainer.id = `table-container-${layer.id}`;
                        tableContainer.style.width = "100%";
                        tableContainer.style.height = "400px";

                        content.appendChild(tableContainer);
                        document.getElementById('tabHeaders').appendChild(header);
                        document.getElementById('tabContents').appendChild(content);

                        selectTab(tabId);

                        require(["esri/widgets/FeatureTable"], function (FeatureTable) {
                            if (featureTables[layer.id]) {
                                featureTables[layer.id].destroy();
                            }

                            const featureTable = new FeatureTable({
                                view: view,
                                layer: layer,
                                container: tableContainer,
                                highlightEnabled: true
                            });

                            featureTables[layer.id] = featureTable;

                            featureTable.on("selection-change", function (event) {
                                const selectedRows = featureTable.selectedItems;

                                if (!event.native || !event.native.shiftKey) {
                                    Object.entries(featureTables).forEach(([id, table]) => {
                                        if (id !== layer.id && table.highlightIds) {
                                            table.highlightIds.removeAll();
                                            table.clearSelection();
                                        }
                                    });

                                    selectedFeatures = [];

                                    if (highlight) {
                                        highlight.remove();
                                        highlight = null;
                                    }
                                }

                                selectedRows.forEach(row => {
                                    const graphic = row.feature; // ‚úÖ CORRECTED HERE
                                    const alreadySelected = selectedFeatures.some(g => g === graphic);
                                    if (!alreadySelected) {
                                        selectedFeatures.push(graphic);
                                    }
                                });

                                if (selectedFeatures.length > 0) {
                                    view.whenLayerView(layer).then(layerView => {
                                        if (highlight) highlight.remove();
                                        highlight = layerView.highlight(selectedFeatures);
                                    });
                                }
                            });
                        });

                        const filterControls = document.createElement("div");
                        filterControls.innerHTML = `
                        <div>
                            <label for="fieldSelect-${layer.id}">Field:</label>
                            <select id="fieldSelect-${layer.id}"></select>
                            <input type="text" id="filterValue-${layer.id}" placeholder="Enter value" />
                            <button id="applyFieldFilter-${layer.id}">Apply Filter</button>
                            <button id="clearFilters-${layer.id}">Clear</button>
                        </div>
                        `;

                        content.appendChild(filterControls);
                        content.appendChild(tableContainer);

                        // Populate field dropdown
                        const fieldSelect = document.getElementById(`fieldSelect-${layer.id}`);
                        layer.fields.forEach(field => {
                        const option = document.createElement("option");
                        option.value = field.name;
                        option.text = field.alias || field.name;
                        fieldSelect.appendChild(option);
                        });

                        // Set up filter button listeners
                        document.getElementById(`applyFieldFilter-${layer.id}`).addEventListener("click", function () {
                        const selectedField = document.getElementById(`fieldSelect-${layer.id}`).value;
                        const filterValue = document.getElementById(`filterValue-${layer.id}`).value;

                        if (!filterValue) {
                            alert("Enter a value to filter!");
                            return;
                        }

                        applyAttributeFilter(layer, selectedField, filterValue);
                        });

                        document.getElementById(`clearFilters-${layer.id}`).addEventListener("click", function () {
                        clearFilters(layer);
                        });
                    }

                    function selectTab(tabId) {
                        // Hide feature list tab
                        const featureListTab = document.getElementById('featureListTab');
                        const featureListButton = document.getElementById('featureListButton');

                        featureListTab.classList.remove('active');
                        featureListTab.style.display = 'none';
                        featureListButton.classList.remove('active');

                        // Set the selected dynamic tab active
                        document.querySelectorAll('.tab-header').forEach(header => {
                        header.classList.toggle('active', header.getAttribute('data-tab-id') === tabId);
                        });

                        document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.toggle('active', content.id === tabId);
                        content.style.display = (content.id === tabId) ? 'block' : 'none';
                        });
                    }

                    function closeTab(tabId, layerId, event) {
                        event.stopPropagation();
                        const contents = document.querySelectorAll('.tab-content');
                        const headers = document.querySelectorAll('.tab-header');
                        const index = Array.from(contents).findIndex(c => c.id === tabId);

                        if (index > -1) {
                            contents[index].remove();
                            headers[index].remove();

                            // Remove tracking of this tab for the layer
                            delete layerTabMap[layerId];

                            // Activate previous tab if any
                            const prevId = contents[index - 1]?.id;
                            if (prevId) selectTab(prevId);
                        }
                    }


                    function applyAttributeFilter(layer, selectedField, filterValue) {
                        console.log(`Applying filter: ${selectedField} = ${filterValue}`);

                        // Find the field type to ensure correct formatting
                        const fieldInfo = layer.fields.find(field => field.name === selectedField);
                        if (!fieldInfo) {
                            console.error(`Field "${selectedField}" not found in layer.`);
                            return;
                        }

                        let formattedValue = filterValue;

                        // Check field type and format the value accordingly
                        if (fieldInfo.type === "integer" || fieldInfo.type === "small-integer") {
                            formattedValue = parseInt(filterValue, 10);
                        } else if (fieldInfo.type === "double" || fieldInfo.type === "float") {
                            formattedValue = parseFloat(filterValue);
                        } else {
                            formattedValue = `'${filterValue}'`; // Wrap strings in quotes for correct query syntax
                        }

                        // Apply Definition Expression (Filter)
                        layer.definitionExpression = `${selectedField} = ${formattedValue}`;
                        
                        console.log(`Filter Applied: ${layer.definitionExpression}`);
                    }

                    function applyGeometryFilter(layer, geometry) {
                        if (!layer) return;

                        console.log(`üìç Applying Geometry Filter...`);

                        // Apply a spatial filter on the FeatureTable
                        if (featureTables[layer.id]) {
                            featureTables[layer.id].filterGeometry = geometry;
                        }
                    }

                    function clearFilters(layer) {
                        console.log(`Clearing filters for: ${layer.title}`);
                        layer.definitionExpression = ""; // Reset filter
                    }

                    document.getElementById("showExportFrame").addEventListener("click", function () {
                        const frame = document.getElementById("exportFrameOverlay");
                        const currentDisplay = window.getComputedStyle(frame).display;
                        frame.style.display = currentDisplay === "none" ? "block" : "none";
                    });

                    function updateExportOverlay() {
                        const overlay = document.getElementById("exportFrameOverlay");

                        const overlayWidth = 600;  // Fixed width
                        const overlayHeight = 600; // Fixed height

                        overlay.style.width = `${overlayWidth}px`;
                        overlay.style.height = `${overlayHeight}px`;

                        // Center it in the map container
                        overlay.style.position = "absolute";
                        overlay.style.left = "50%";
                        overlay.style.top = "50%";
                        overlay.style.transform = "translate(-50%, -50%)";
                    }

                    view.when(() => {
                        updateExportOverlay();
                    });

                    window.addEventListener("resize", updateExportOverlay);

                    // Symbol for Polylines (Lines)
                    const lineSymbol = new SimpleLineSymbol({
                        color: [0, 225, 255],  
                        width: 3  // Line width
                    });

                    // Define the symbol for the drawn polygon
                    const polygonSymbol = new SimpleFillSymbol({
                        color: [0, 225, 255, 0.3],  // Fill color with 30% opacity (blue)
                        outline: new SimpleLineSymbol({
                            color: [0, 0, 255],  // Blue outline color
                            width: 2  // Width of the outline
                        })
                    });

                    // Symbol for Points
                    const pointSymbol = new SimpleMarkerSymbol({
                        color: [0, 225, 255, , 0.1],  
                        size: 6,  // Size of the point
                        outline: {
                            color: [0, 0, 255],  // Black outline
                            width: 1
                        }
                    });

                    document.getElementById("applyBuffer").addEventListener("click", function () {
                        const bufferDistance = parseFloat(document.getElementById("bufferDistance").value);
                        const bufferUnits = document.getElementById("bufferUnits").value;

                        if (isNaN(bufferDistance) || bufferDistance <= 0) {
                            alert("Please enter a valid buffer distance.");
                            return;
                        }

                        const bufferResults = []; // Store resulting buffered geometries

                        // üü° Option 1: Buffer selected features
                        if (selectedFeatures.length > 0) {
                            const bufferGeometries = [];

                            selectedFeatures.forEach((feature) => {
                                const buffered = geometryEngine.buffer(feature.geometry, bufferDistance, bufferUnits);
                                if (buffered) {
                                    bufferGeometries.push(buffered);
                                }
                            });

                            if (bufferGeometries.length > 0) {
                                // üß© Union (dissolve) all buffer geometries into one
                                const dissolved = geometryEngine.union(bufferGeometries);

                                // Create one graphic from the dissolved result
                                const dissolvedGraphic = new Graphic({
                                    geometry: dissolved,
                                    symbol: {
                                        type: "simple-fill",
                                        color: [0, 0, 255, 0.3],
                                        outline: { color: [0, 0, 255], width: 2 }
                                    }
                                });

                                bufferResults.push(dissolvedGraphic);
                            }
                        }


                        // üîµ Option 2: Buffer a sketched graphic
                        else if (selectedGraphic && selectedGraphic.geometry) {
                            const buffered = geometryEngine.buffer(selectedGraphic.geometry, bufferDistance, bufferUnits);
                            if (buffered) {
                                bufferResults.push(new Graphic({
                                    geometry: buffered,
                                    symbol: {
                                        type: "simple-fill",
                                        color: [0, 0, 255, 0.3],
                                        outline: { color: [0, 0, 255], width: 2 }
                                    }
                                }));
                            }
                        }

                        // ‚ùå Nothing to buffer
                        else {
                            alert("Please draw or select a feature to buffer.");
                            return;
                        }

                        if (bufferResults.length === 0) {
                            console.error("‚ùå No buffers created.");
                            return;
                        }

                        // ‚úÖ Create new graphics layer for buffer results
                        const bufferLayer = new GraphicsLayer({
                            title: `Buffer ${Date.now()}`
                        });

                        bufferResults.forEach(g => bufferLayer.add(g));
                        bufferLayer._originalGraphics = bufferResults;
                        map.add(bufferLayer);
                        console.log("‚úÖ Buffer layer added to map.");

                        // üî• Add buffer layer to the UI list
                        addLayerToList(bufferLayer);

                        console.log("Buffered geometry type:", bufferLayer.type);


                        // Query layers for intersecting features
                        const layers = allLayers.filter(layer => layer.visible);

                        layers.forEach(layer => {
                            const query = layer.createQuery();
                            query.geometry = bufferResults;
                            query.spatialRelationship = "intersects";
                            query.returnGeometry = true;
                            query.outFields = layerFields[layer.title] || ["*"];

                            console.log(`üîç Querying layer: ${layer.title}`);

                            layer.queryFeatures(query).then(results => {
                                console.log(`‚úÖ Found ${results.features.length} features in ${layer.title}`);

                                let layerTotalArea = 0;
                                let layerTotalLength = 0;
                                let pointCount = 0;
                                let isPointLayer = false;
                                let featureCount = results.features.length;

                                results.features.forEach(feature => {
                                    if (feature.geometry) {
                                        const intersectedGeometry = geometryEngine.intersect(feature.geometry, bufferLayer);

                                        if (intersectedGeometry) {
                                            let featureArea = 0;
                                            let featureLength = 0;

                                            if (intersectedGeometry.type === "polygon") {
                                                featureArea = geometryEngine.geodesicArea(intersectedGeometry, "square-meters");
                                            }

                                            if (intersectedGeometry.type === "polyline") {
                                                featureLength = geometryEngine.geodesicLength(intersectedGeometry, "meters");
                                            }
                                            if (intersectedGeometry.type === "point") {
                                                pointCount++;
                                                isPointLayer = true; 
                                            }

                                            layerTotalArea += featureArea;
                                            layerTotalLength += featureLength;

                                            let symbol;
                                                if (feature.geometry.type === "polygon") {
                                                    symbol = polygonSymbol;
                                                } else if (feature.geometry.type === "polyline") {
                                                    symbol = lineSymbol;
                                                } else if (feature.geometry.type === "point") {
                                                    symbol = pointSymbol;
                                                }

                                                const highlightGraphic = new Graphic({
                                                    geometry: feature.geometry,
                                                    symbol: symbol
                                                });

                                                graphicsLayer.add(highlightGraphic);
                                        
                                        }
                                    }
                                });

                                console.log(`üìå Layer: ${layer.title}`);
                                console.log(`‚úîÔ∏è Total Features Selected: ${featureCount}`);
                                console.log(`‚úîÔ∏è Total Area: ${layerTotalArea.toFixed(2)} sq. meters`);
                                console.log(`‚úîÔ∏è Total Length: ${layerTotalLength.toFixed(2)} meters`);
                                console.log(`‚úîÔ∏è Total points Selected: ${pointCount}`);
                               

                                updateFeatureTable(layer, featureCount, layerTotalArea, layerTotalLength, isPointLayer, pointCount);
                            }).catch(error => {
                                console.error(`‚ùå Error querying layer ${layer.title}:`, error);
                            });
                        });
                    });

                    function queryLayers(geometry, bufferDistance) {
                        // Check if bufferDistance is provided and apply buffer to the geometry
                        const bufferGeometry = bufferDistance > 0 ? geometryEngine.buffer(geometry, bufferDistance, "meters") : geometry;

                        const attributeList = document.getElementById("featureList");
                        attributeList.innerHTML = ''; // Clear previous results

                        const layers = allLayers.filter(layer => layer.visible);

                        layers.forEach(layer => {
                            const query = layer.createQuery();
                            query.geometry = bufferGeometry; // Use buffered geometry
                            query.spatialRelationship = "intersects";
                            query.returnGeometry = true;
                            query.outFields = layerFields[layer.title] || ["*"];

                            console.log(`üîç Querying layer: ${layer.title}`);

                            layer.queryFeatures(query).then((results) => {
                                const featureCount = results.features.length;
                                console.log(`‚úÖ Found ${featureCount} features in ${layer.title}`);

                                if (featureCount === 0) {
                                    console.log(`‚ùå No features found in ${layer.title}. Skipping.`);
                                    return; // Skip if no features found
                                }

                                let totalArea = 0;
                                let totalLength = 0;
                                let pointCount = 0;
                                let isPointLayer = false;  // Initially set to false

                                results.features.forEach(feature => {
                                    let featureArea = 0;
                                    let featureLength = 0;

                                    if (feature.geometry) {
                                        const intersectedGeometry = geometryEngine.intersect(feature.geometry, bufferGeometry);

                                        if (intersectedGeometry) {
                                            if (intersectedGeometry.type === "polygon") {
                                                featureArea = geometryEngine.geodesicArea(intersectedGeometry, "square-meters");
                                            }
                                            if (intersectedGeometry.type === "polyline") {
                                                featureLength = geometryEngine.geodesicLength(intersectedGeometry, "meters");
                                            }
                                            if (intersectedGeometry.type === "point") {
                                                pointCount++; 
                                                isPointLayer = true; 
                                            }
                                        }
                                    }

                                    totalArea += featureArea;
                                    totalLength += featureLength;

                                    let symbol;
                                    if (feature.geometry.type === "polygon") {
                                        symbol = polygonSymbol;
                                    } else if (feature.geometry.type === "polyline") {
                                        symbol = lineSymbol;
                                    } else if (feature.geometry.type === "point") {
                                        symbol = pointSymbol;
                                    }

                                    const highlightGraphic = new Graphic({
                                        geometry: feature.geometry,
                                        symbol: symbol
                                    });

                                    graphicsLayer.add(highlightGraphic);
                                });

                                console.log(`üìå Updating table for ${layer.title}: ${featureCount} features`);

                                // Safely add the results to the table
                                updateFeatureTable(layer, featureCount, totalArea, totalLength, isPointLayer, pointCount);
                            }).catch(error => {
                                console.error(`‚ùå Error querying layer ${layer.title}:`, error);
                            });
                        });
                    }


                    function exportGeometry(format, layer = null) {

                        console.log("üîé Layer provided:", !!layer);
                        console.log("üîé Layer title:", layer?.title);
                        console.log("üîé layer.graphics:", layer.graphics);
                        console.log("üîé layer._originalGraphics:", layer._originalGraphics);

                        // Load the geometry service module
                        require([
                            "esri/rest/geometryService",
                            "esri/rest/support/ProjectParameters",
                            "esri/geometry/SpatialReference"
                            ], function(geometryService, ProjectParameters, SpatialReference) {
                            const geometryServiceUrl = "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer";

                            if (layer) {
                                console.log("üì¶ Exporting multiple geometries from layer:", layer.title);
                                console.log("üîé _originalGraphics on layer:", layer._originalGraphics);

                                const graphics = layer._originalGraphics || [];
                                if (graphics.length === 0) {
                                    console.error("‚ùå No original graphics stored for export in layer:", layer.title);
                                    return;
                                }

                                const geometries = graphics.map(graphic => graphic.geometry);
                                console.log("üß† Number of graphics in layer:", graphics.length);
                                console.log("üì¶ Collected geometries:", geometries);

                                const params = new ProjectParameters({
                                    geometries: geometries,
                                    outSpatialReference: new SpatialReference({ wkid: 4326 })
                                });

                                geometryService.project(geometryServiceUrl, params).then(function(projectedGeometries) {
                                    console.log("‚úÖ Projected geometries:", projectedGeometries);
                                    if (format === "kml") {
                                        exportMultipleToKML(projectedGeometries, layer.title + ".kml");
                                    } else if (format === "gpx") {
                                        // GPX export logic if needed
                                    }
                                }).catch(function(error) {
                                    console.error("Error projecting geometries:", error);
                                    alert("‚ùå Error processing geometries for export.");
                                });
                            

                            } else {
                                console.log("üìç Exporting a single geometry...");
                                // SINGLE SELECTED OR BUFFERED FEATURE
                                if (!selectedOrBufferedGraphic) {
                                    alert("‚ùå No geometry selected or buffered to export.");
                                    return;
                                }
                                console.log("Selected/buffered graphic geometry:", selectedOrBufferedGraphic.geometry);

                                const params = new ProjectParameters({
                                    geometries: [selectedOrBufferedGraphic.geometry],
                                    outSpatialReference: new SpatialReference({ wkid: 4326 })
                                });

                                geometryService.project(geometryServiceUrl, params).then(function(projectedGeometries) {
                                    const projectedGeometry = projectedGeometries[0];
                                    console.log("‚úÖ Projected single geometry:", projectedGeometry);
                                    if (format === "kml") {
                                        exportSingleGeometry("kml", projectedGeometry, "exported-feature.kml");
                                    } else if (format === "gpx") {
                                        exportToGPX(projectedGeometry);
                                    }
                                }).catch(function(error) {
                                    console.error("Error projecting geometry:", error);
                                    alert("‚ùå Error processing geometry for export.");
                                });
                            }
                        });
                    }

                    // Function to convert geometry to KML and download
                    function exportMultipleToKML(geometries, filename) {
                            let kml = `<?xml version="1.0" encoding="UTF-8"?>
                        <kml xmlns="http://www.opengis.net/kml/2.2">
                        <Document>
                        <name>${filename}</name>`;

                            geometries.forEach((geometry, index) => {
                                kml += `
                        <Placemark>
                            <name>Feature ${index + 1}</name>`;

                                if (geometry.type === "point") {
                                    kml += `
                            <Point>
                            <coordinates>${geometry.longitude},${geometry.latitude}</coordinates>
                            </Point>`;
                                } else if (geometry.type === "polyline") {
                                    const pathCoords = geometry.paths.map(path =>
                                        path.map(point => `${point[0]},${point[1]}`).join(" ")
                                    ).join(" ");

                                    kml += `
                            <LineString>
                            <coordinates>${pathCoords}</coordinates>
                            </LineString>`;
                                } else if (geometry.type === "polygon") {
                                    kml += `
                            <Polygon>
                            <outerBoundaryIs>
                                <LinearRing>
                                <coordinates>
                                    ${geometry.rings[0].map(point => `${point[0]},${point[1]}`).join(" ")}
                                </coordinates>
                                </LinearRing>
                            </outerBoundaryIs>`;

                                    for (let i = 1; i < geometry.rings.length; i++) {
                                        kml += `
                            <innerBoundaryIs>
                                <LinearRing>
                                <coordinates>
                                    ${geometry.rings[i].map(point => `${point[0]},${point[1]}`).join(" ")}
                                </coordinates>
                                </LinearRing>
                            </innerBoundaryIs>`;
                                    }

                                    kml += `
                            </Polygon>`;
                                }

                                kml += `
                        </Placemark>`;
                            });

                            kml += `
                        </Document>
                        </kml>`;

                            // Download the KML file
                            downloadFile(kml, filename, 'application/vnd.google-earth.kml+xml');
                    }


                    // Function to convert geometry to GPX and download
                    function exportToGPX(geometry) {
                        let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
                        gpx += '<gpx version="1.1" creator="ArcGIS Web Application" xmlns="http://www.topografix.com/GPX/1/1">\n';
                        
                        // Handle different geometry types
                        if (geometry.type === "point") {
                            gpx += '  <wpt lat="' + geometry.latitude + '" lon="' + geometry.longitude + '">\n';
                            gpx += '    <name>Exported Point</name>\n';
                            gpx += '  </wpt>\n';
                        } else if (geometry.type === "polyline") {
                            gpx += '  <trk>\n';
                            gpx += '    <name>Exported Track</name>\n';
                            
                            geometry.paths.forEach((path, index) => {
                                gpx += '    <trkseg>\n';
                                path.forEach(point => {
                                    gpx += '      <trkpt lat="' + point[1] + '" lon="' + point[0] + '"></trkpt>\n';
                                });
                                gpx += '    </trkseg>\n';
                            });
                            
                            gpx += '  </trk>\n';
                        } else if (geometry.type === "polygon") {
                            // GPX doesn't natively support polygons, so we'll convert the outer ring to a track
                            gpx += '  <trk>\n';
                            gpx += '    <name>Exported Area Boundary</name>\n';
                            gpx += '    <trkseg>\n';
                            
                            // Use the outer ring
                            geometry.rings[0].forEach(point => {
                                gpx += '      <trkpt lat="' + point[1] + '" lon="' + point[0] + '"></trkpt>\n';
                            });
                            
                            // Close the loop by adding the first point again
                            if (geometry.rings[0].length > 0) {
                                const firstPoint = geometry.rings[0][0];
                                gpx += '      <trkpt lat="' + firstPoint[1] + '" lon="' + firstPoint[0] + '"></trkpt>\n';
                            }
                            
                            gpx += '    </trkseg>\n';
                            gpx += '  </trk>\n';
                        }
                        
                        gpx += '</gpx>';
                        
                        // Create a download link
                        downloadFile(gpx, 'exported-feature.gpx', 'application/gpx+xml');
                    }

                    // Helper function to download a file
                    function downloadFile(content, fileName, mimeType) {
                        const blob = new Blob([content], { type: mimeType });
                        const blobUrl = URL.createObjectURL(blob);

                        // Handle opening the file in a new tab
                        const newTab = window.open();
                        if (newTab) {
                            if (mimeType === "application/pdf") {
                                // For PDF, use embed
                                newTab.document.write(
                                    `<html><body><embed width="100%" height="100%" src="${blobUrl}" type="${mimeType}"></embed></body></html>`
                                );
                            } else {
                                // For KML/GPX or non-viewable files, just provide a download link
                                newTab.document.write(
                                    `<html><body><h3>Your file is ready for download.</h3><a href="${blobUrl}" download="${fileName}">Click here to download the ${fileName}</a></body></html>`
                                );
                            }
                            console.log("File opened in new tab");
                        } else {
                            console.error("Pop-up blocked! Unable to open new window.");
                            alert("Pop-up blocked! Please allow pop-ups for this site.");
                        }

                        // Trigger download in the current tab as well
                        const link = document.createElement('a');
                        link.href = blobUrl;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        // Delay the cleanup to ensure the file is downloaded
                        setTimeout(function() {
                            // Revoke the Blob URL after a delay to give time for the file download
                            URL.revokeObjectURL(blobUrl);
                        }, 2000);  // 2-second delay should be enough
                    }


                    function updateFeatureTable(layer, featureCount, totalArea, totalLength, isPointLayer, pointCount) {
                        console.log(`üîÑ Updating table for ${layer.title}`);

                        const featureTableContainer = document.getElementById("featureList");

                        let layerTable = document.getElementById("globalFeatureTable");

                        if (!layerTable) {
                            layerTable = document.createElement("table");
                            layerTable.id = "globalFeatureTable";
                            layerTable.style.width = "100%";
                            layerTable.style.borderCollapse = "collapse";

                            const headerRow = document.createElement("tr");
                            ["NAME", "COUNT", "AREA", "LENGTH"].forEach(headerText => {
                                const th = document.createElement("th");
                                th.textContent = headerText;
                                th.style.border = "1px solid black";
                                th.style.padding = "5px";
                                th.style.textAlign = "left";
                                headerRow.appendChild(th);
                            });

                            const thead = document.createElement("thead");
                            thead.appendChild(headerRow);
                            layerTable.appendChild(thead);

                            const tbody = document.createElement("tbody");
                            tbody.id = "globalFeatureTableBody";
                            layerTable.appendChild(tbody);

                            featureTableContainer.appendChild(layerTable);
                        }

                        const tbody = document.getElementById("globalFeatureTableBody");

                        let layerRow = document.getElementById(`row-${layer.id}`);

                        if (!layerRow) {
                            layerRow = document.createElement("tr");
                            layerRow.id = `row-${layer.id}`;

                            ["NAME", "COUNT", "AREA", "LENGTH"].forEach((col, index) => {
                                const td = document.createElement("td");
                                td.style.border = "1px solid black";
                                td.style.padding = "5px";

                                if (index === 0) {
                                    td.textContent = layer.title;
                                } else {
                                    td.textContent = "0";
                                }

                                td.id = `cell-${layer.id}-${col.toLowerCase()}`;
                                layerRow.appendChild(td);
                            });

                            tbody.appendChild(layerRow);
                        }

                        const countCell = document.getElementById(`cell-${layer.id}-count`);
                        const areaCell = document.getElementById(`cell-${layer.id}-area`);
                        const lengthCell = document.getElementById(`cell-${layer.id}-length`);

                        // Update the count for features
                        countCell.textContent = isPointLayer ? pointCount : featureCount;  // Use point count for point layers

                        // ‚úÖ If it's a point layer, display count, but leave area/length as "-"
                        if (isPointLayer) {
                            areaCell.textContent = "-";   // No area for points
                            lengthCell.textContent = "-"; // No length for points
                        } else {
                            areaCell.textContent = totalArea > 0 ? totalArea.toFixed(2) : "-";
                            lengthCell.textContent = totalLength > 0 ? totalLength.toFixed(2) : "-";
                        }

                        // ‚ùå REMOVE ROWS IF COUNT DROPS TO 0
                        if (featureCount === 0) {
                            console.log(`üö® Removing ${layer.title} from the table (0 features)`);
                            layerRow.remove();
                        }
                    }

                    


                    const sketchLayer = view.map.findLayerById("graphicsLayer");
                    console.log("üß™ graphicsLayer.graphics count:", sketchLayer.graphics.length);
                    console.log("üß™ graphicsLayer.graphics sample:", sketchLayer.graphics.map(g => g.geometry));

                    function convertGraphicsLayerToFeatureCollection(graphicsLayer) {
                        if (!graphicsLayer || !graphicsLayer.graphics || graphicsLayer.graphics.length === 0) {
                            console.warn("‚ùå No graphics in graphicsLayer to convert.");
                            return null;
                        }

                        const firstGraphic = graphicsLayer.graphics.find(g => g.geometry);
                        if (!firstGraphic) {
                            console.warn("‚ùå No valid geometries in graphicsLayer.");
                            return null;
                        }

                        const features = graphicsLayer.graphics.map(graphic => {
                            return {
                                geometry: graphic.geometry?.toJSON(), // Safe access
                                attributes: graphic.attributes || {}
                            };
                        });

                        const geometryType = firstGraphic.geometry.type;

                        const fields = [
                            { name: "OBJECTID", alias: "OBJECTID", type: "esriFieldTypeOID" }
                        ];

                        const sampleAttributes = firstGraphic.attributes || {};
                        for (const key in sampleAttributes) {
                            if (key !== "OBJECTID") {
                                fields.push({
                                    name: key,
                                    alias: key,
                                    type: "esriFieldTypeString"
                                });
                            }
                        }

                        return {
                            id: "sketchLayer",
                            title: "Sketch Layer",
                            layerType: "FeatureCollection",
                            opacity: 1,
                            visibility: true,
                            featureCollection: {
                                layers: [
                                    {
                                        layerDefinition: {
                                            name: "Sketch Layer",
                                            geometryType: `esriGeometry${geometryType.charAt(0).toUpperCase()}${geometryType.slice(1)}`,
                                            fields: fields,
                                            drawingInfo: {
                                                renderer: {
                                                    type: "simple",
                                                    symbol: getDefaultSymbolForGeometryType(geometryType)
                                                }
                                            }
                                        },
                                        featureSet: {
                                            geometryType: `esriGeometry${geometryType.charAt(0).toUpperCase()}${geometryType.slice(1)}`,
                                            features: features
                                        }
                                    }
                                ]
                            }
                        };
                    }

                    function convertFeatureLayerToFeatureCollection(layer) {
                        // Use queryFeatures to respect definitionExpression and get filtered data
                        return layer.queryFeatures({
                            where: layer.definitionExpression || "1=1",
                            returnGeometry: true,
                            outFields: ["*"]
                        }).then(result => {
                            const features = result.features.map(f => f.toJSON());

                            if (!features.length) {
                            console.warn(`‚ö†Ô∏è No features in layer "${layer.title}" match the filter.`);
                            return null;
                            }

                            return {
                            id: layer.id,
                            title: layer.title,
                            layerType: "FeatureLayer",
                            featureSet: {
                                features: features,
                                geometryType: layer.geometryType
                            },
                            drawingInfo: layer.renderer.toJSON(),
                            fields: layer.fields
                            };
                        });
                    }


                    function getDefaultSymbolForGeometryType(type) {
                        switch (type) {
                            case "polygon":
                                return {
                                    type: "esriSFS",
                                    style: "esriSFSSolid",
                                    color: [255, 0, 0, 64],
                                    outline: {
                                        color: [255, 0, 0, 255],
                                        width: 2,
                                        type: "esriSLS",
                                        style: "esriSLSSolid"
                                    }
                                };
                            case "polyline":
                                return {
                                    type: "esriSLS",
                                    style: "esriSLSSolid",
                                    color: [255, 0, 0, 255],
                                    width: 3
                                };
                            case "point":
                            default:
                                return {
                                    type: "esriSMS",
                                    style: "esriSMSCircle",
                                    color: [255, 0, 0, 255],
                                    size: 8,
                                    outline: {
                                        color: [0, 0, 0, 255],
                                        width: 1
                                    }
                                };
                        }
                    }

                    function getAllFeatureCollectionsFromMap() {
                        const allCollections = [];

                        map.layers.forEach(layer => {
                            if (layer.type === "graphics" && layer.graphics.length > 0) {
                                const fc = convertGraphicsLayerToFeatureCollection(layer);
                                if (fc) {
                                    allCollections.push(fc);
                                }
                            }
                        });

                        if (allCollections.length === 0) {
                            console.warn("‚ùå No graphics found in any graphics layer.");
                            return null;
                        }

                        return allCollections;
                    }


                    document.getElementById("exportGeoPDF").addEventListener("click", function () {
                        console.log("Export button clicked - starting PDF load function...");
                        
                        const loader = document.getElementById("pdfLoader");
                        loader.style.display = "block"; // Show loader
                        
                        exportGeoPDF().finally(() => {
                            loader.style.display = "none"; // Hide loader after export (even on error)
                        });
                    });

                    async function exportGeoPDF() {

                        const webMapJSON = {
                            mapOptions: {
                                extent: window.view.extent.toJSON(),
                                spatialReference: window.view.spatialReference.toJSON()
                            },
                            spatialReference: window.view.spatialReference.toJSON(),
                            exportOptions: {
                                dpi: 96,
                                outputSize: [800, 600],
                                showAttribution: false
                            },
                            baseMap: {
                                title: "World Topographic Map",
                                baseMapLayers: [
                                    {
                                    id: "world-topo",
                                    opacity: 1,
                                    visibility: true,
                                    url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer",
                                    layerType: "ArcGISTiledMapServiceLayer"
                                    }
                                ]
                            },
                            
                            operationalLayers: window.view.map.layers.items
                                .filter(layer => layer.url)
                                
                                .map(layer => ({
                                id: layer.id,
                                title: layer.title || layer.id,
                                opacity: layer.opacity,
                                visibility: layer.visible,
                                url: layer.url,
                                layerType: (layer.type === "feature")
                                    ? "ArcGISFeatureLayer"
                                    : "ArcGISMapServiceLayer"
                                }))
                        };

                        webMapJSON.baseMap.baseMapLayers = webMapJSON.baseMap.baseMapLayers.map(layer => {
                            // Normalize URL to ensure protocol is included
                            const normalizedUrl = layer.url?.startsWith("//")
                                ? "https:" + layer.url
                                : layer.url;

                            // Replace specific problematic URLs
                            if (
                                normalizedUrl === "https://services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
                            ) {
                                layer.url = "https://services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"; // keep as-is or point to a local version
                            } else if (
                                normalizedUrl === "https://cdn.arcgis.com/sharing/rest/content/items/7dc6cea0b1764a1f9af2e679f642f0f5/resources/styles/root.json"
                            ) {
                                layer.url = "https://services.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer";
                            }

                            return layer;
                        });

                        webMapJSON.operationalLayers.forEach(layer => {
                            if (layer.title === "Fire Points") {
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/MRG_Fire_History_Fire_Points/FeatureServer/1";
                            } else if (layer.title === "Rogers Pass Historic Infrastructure Points") {
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Historic_RP/FeatureServer/1";
                            } else if (layer.title === "MR Stream Order") {
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Hydrology/FeatureServer/1";
                            } else if (layer.title === "TCH") {
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/TCHOneLine/FeatureServer/1";
                            } else if (layer.title === "Trails") {
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Hosted/Facilities__Infrastructure/FeatureServer/3";
                            } else if (layer.title === "Rogers Pass Imagery") {
                                // Do NOT append /0 ‚Äî keep it as is
                                layer.url = "https://geo-x.apca2.gc.ca/arcserver/rest/services/RogersPass_Imagery/MapServer";
                            } else {
                                // For all others, append /0 if it's a FeatureServer and not already present
                                if (
                                layer.layerType === "ArcGISFeatureLayer" &&
                                !layer.url.endsWith("/0") &&
                                !/\/\d+$/.test(layer.url)
                                ) {
                                layer.url += "/0";
                                }
                            }
                        });

                        const printTaskUrl = "https://geo-x.apca2.gc.ca/arcserver/rest/services/Printing/ExportWebMap/GPServer/Export%20Web%20Map/execute";

                        

                        const sketchCollections = getAllFeatureCollectionsFromMap();

                        if (sketchCollections) {
                            sketchCollections.forEach(fc => {
                                webMapJSON.operationalLayers.push(fc);
                            });
                            console.log(`‚úÖ Added ${sketchCollections.length} graphics layers to export.`);
                        } else {
                            console.log("‚ÑπÔ∏è No sketch graphics to export. Continuing without them.");
                        }

                        // Include layers with no URL by converting them into feature collections
                        const nonUrlLayers = await Promise.all(
                            window.view.map.layers.items
                                .filter(layer => !layer.url && typeof layer.queryFeatures === "function")
                                .map(async layer => {
                                    try {
                                        const result = await layer.queryFeatures({
                                            where: layer.definitionExpression || "1=1",
                                            returnGeometry: true,
                                            outFields: ["*"]
                                        });

                                        const featureCollection = {
                                            id: layer.id || "graphics-layer",
                                            title: layer.title || "Graphics Layer",
                                            visibility: layer.visible,
                                            opacity: layer.opacity ?? 1,
                                            layerType: "FeatureCollection",
                                            featureCollection: {
                                                layers: [{
                                                    layerDefinition: {
                                                        geometryType: result.geometryType,
                                                        objectIdField: "OBJECTID",
                                                        drawingInfo: {
                                                            renderer: {
                                                                type: "simple",
                                                                symbol: {
                                                                    type: "esriSFS",
                                                                    style: "esriSFSSolid",
                                                                    color: [255, 0, 0, 128],
                                                                    outline: {
                                                                        color: [0, 0, 0, 255],
                                                                        width: 1,
                                                                        type: "esriSLS",
                                                                        style: "esriSLSSolid"
                                                                    }
                                                                }
                                                            },
                                                            transparency: 0
                                                        },
                                                        fields: result.fields ?? [{
                                                            name: "OBJECTID",
                                                            alias: "OBJECTID",
                                                            type: "esriFieldTypeOID"
                                                        }]
                                                    },
                                                    featureSet: {
                                                        features: result.features.map(f => f.toJSON()),
                                                        geometryType: result.geometryType
                                                    }
                                                }]
                                            }
                                        };

                                        console.log(`‚úÖ Converted non-URL layer to featureCollection: ${layer.title || layer.id}`);
                                        return featureCollection;
                                    } catch (err) {
                                        console.warn(`‚ö†Ô∏è Could not convert layer ${layer.title || layer.id}:`, err);
                                        return null;
                                    }
                                })
                        );

                        // Filter out any nulls and add to operationalLayers
                        nonUrlLayers
                            .filter(fc => fc !== null)
                            .forEach(fc => webMapJSON.operationalLayers.push(fc));


                        

                        console.log("Sending Web_Map_as_JSON to print service:", JSON.stringify(webMapJSON, null, 2));

                        const params = new URLSearchParams({
                            f: "json",
                            Format: "PDF",
                            Layout_Template: "MAP_ONLY",
                            Web_Map_as_JSON: JSON.stringify(webMapJSON),
                        });


                        const response = await fetch(printTaskUrl, {
                            method: "POST",
                            headers: {
                            "Content-Type": "application/x-www-form-urlencoded",
                            },
                            body: params,
                        });

                        const result = await response.json();
                        const pdfUrl = result?.results?.[0]?.value?.url;

                        if (pdfUrl) {
                            window.open(pdfUrl, "_blank");
                        } else {
                            console.error("Export failed. No URL returned.");
                        }

                        return; // ‚õî Exit after GeoPDF export
                    }


                    document.getElementById("csvButton").addEventListener("click", function () {
                        const table = document.getElementById("globalFeatureTable");

                        console.log("csv export button clicked")

                        if (!table) {
                            console.log("No data available to export.");
                            return;
                        }

                        let csvContent = [];
                        const rows = table.querySelectorAll("tr");
                        

                        rows.forEach((row, index) => {
                            let rowData = [];
                            row.querySelectorAll("th, td").forEach(cell => rowData.push(cell.textContent));
                            csvContent += rowData.join(",") + "\n";
                        });

                        // Convert CSV content into a Blob
                        const blob = new Blob([csvContent], { type: "text/csv" });
                        const blobURL = URL.createObjectURL(blob);

                        // Get the div where the link should be placed
                        const csvLinkDiv = document.getElementById("csvLink");
                        // Create a download link
                        csvLinkDiv.innerHTML = ""; // Clear previous links

                        const link = document.createElement("a");
                        link.href = blobURL;
                        link.download = "feature_table.csv";
                        link.textContent = 'Download CSV File: Right click "open link in new tab"';

                        // Append the link to the div
                        csvLinkDiv.appendChild(link);
                    });

                    // Listen for the completion of a sketch (either draw or edit) - This controls the results of the selection DO NOT CHANGE
                    sketch.on("create", function(event) {
                        if (event.state === "complete") {
                        // Query layers when the sketch is finished
                        queryLayers(event.graphic.geometry);
                        }
                    });
                    

                    // Clear Button
                    document.getElementById("clearBtn").addEventListener("click", function() {
                        graphicsLayer.removeAll();
                    });

                    document.getElementById("refreshButton").addEventListener("click", function() {
                        document.getElementById("featureList").innerHTML = '';
                    });

                    // Store view globally for export function
                    window.view = view;
                    console.log("Esri MapView initialized!");
               
                });
            
            };
            document.body.appendChild(esriScript);
        
        } else {
            console.error("jsPDF is not loaded.");
        }
    }
    
  </script>
</body>
</html>